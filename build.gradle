plugins {
    id 'de.undercouch.download'
    id 'uk.jamierocks.propatcher' version '2.0.1' apply false
}

import de.undercouch.gradle.tasks.download.Download
import groovy.json.JsonBuilder
import net.minecraftforge.mcpconfig.tasks.*
import net.minecraftforge.srgutils.MinecraftVersion
import org.codehaus.groovy.runtime.callsite.BooleanClosureWrapper
import uk.jamierocks.propatcher.task.*

import java.nio.file.Files

group = 'de.oceanlabs.mcp'

net.minecraftforge.mcpconfig.tasks.Utils.init()

final String PATH_BUILD = file('build').absolutePath
final MinecraftVersion MC_1_16_5 = MinecraftVersion.from('1.16.5')
final List<String> VERSIONS = subprojects.collect{it.name}.sort{ a,b -> MinecraftVersion.from(a) <=> MinecraftVersion.from(b) }
final String TIMESTAMP = (new Date()).format('yyyyMMdd.HHmmss')
ext {
    ASM_VERSION = '9.2'
    SRGUTILS_VERSION = '0.5.3'
}

logger.lifecycle('Timestamp: ' + TIMESTAMP)

final File downloadVersionManifestDest = file('build/versions/version_manifest.json')
tasks.register('downloadVersionManifest', Download) {
    src 'https://launchermeta.mojang.com/mc/game/version_manifest_v2.json'
    dest downloadVersionManifestDest
    useETag 'all'
    onlyIfModified true
    quiet true
}

/* This check is fucked on anything > J8 because modules use a propriatary file format. We'd have to create an extracter 
 * that runs in the external process.. so fuck it.
 
task downloadRuntimeManifest(type: Download) {
    src 'https://launchermeta.mojang.com/v1/products/java-runtime/2ec0cc96c44e5a76b9c8b7c39df7210883d12871/all.json'
    dest file('build/versions/java-runtime-all.json')
    useETag 'all'
    onlyIfModified true
    quiet true
}

task downloadRuntime(type:DownloadRuntime, dependsOn: downloadRuntimeManifest) {
    json = downloadRuntimeManifest.dest
    os = 'windows-x64'
    doFirst {
        downloadRuntimeManifest.dest.json.get('windows-x64').keySet().each{ dest.put(it, file('build/runtimes/' + it)) }
    }
}

task extractRuntimeApi(type: ExtractAPI, dependsOn: downloadRuntime) {
    doFirst {
        downloadRuntimeManifest.dest.json.get('windows-x64').keySet().each {
            roots.put(it, new File(downloadRuntime.dest.get(it), 'files'))
            apis.put(it, new File(downloadRuntime.dest.get(it), 'api.json'))
        }
    }
}
*/

if (project.hasProperty('old_version') && project.hasProperty('new_version')) {
    println('Update Old: ' + project.getProperty('old_version') + ' New: ' + project.getProperty('new_version'))
    apply from: 'update.gradle'
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'de.undercouch.download'
    apply plugin: 'maven-publish'
    
    group = rootProject.group
    version = name

    final MinecraftVersion MC_VERSION = MinecraftVersion.from(project.name)
    final String PATH_CACHED_LIBRARIES = PATH_BUILD + '/libraries/'
    final String PATH_CACHED_VERSION = PATH_BUILD + '/versions/' + project.version + '/'
    final String PATH_CACHED_VERSION_DATA = PATH_CACHED_VERSION + 'data/'
    final File PATH_INJECT = file('inject')
    final File PATH_INJECT_TEMPLATE = new File(PATH_INJECT, 'package-info-template.java')
    final File PATH_NATIVES = file('projects/natives')
    ext {
        CONFIG = file('config.json').json
        JAVA_TARGET = CONFIG.get('java_target', 8)
        ENCODING = CONFIG.get('encoding', 'UTF-8')
        FERNFLOWER = Utils.readConfig(CONFIG, 'fernflower', [:])        
        MERGETOOL = Utils.readConfig(CONFIG, 'merge', [
            version: 'net.minecraftforge:mergetool:1.1.3:fatjar',
            args: ["--client", "{client}", "--server", "{server}", "--ann", "{version}", "--output", "{output}"]
        ])
        RENAMETOOL = Utils.readConfig(CONFIG, 'rename', [
            version: 'net.minecraftforge.lex:vignette:0.2.0.7',
            args: ['--jar-in', '{input}', '--jar-out', '{output}', '--mapping-format', 'tsrg2', '--mappings', '{mappings}', '--fernflower-meta', '--cfg', '{libraries}']
        ])
        MERGEMAPTOOL = Utils.readConfig(CONFIG, 'mergemap', [
            version: 'net.minecraftforge:installertools:1.2.0:fatjar',
            args: ['--task', 'MERGE_MAPPING', '--left', '{mappings}', '--right', '{official}', '--right-names', 'right,left', '--classes', '--output', '{output}']
        ])
        MCINJECTOR = null
        if (CONFIG.containsKey('mcinjector'))
            MCINJECTOR = Utils.readConfig(CONFIG, 'mcinjector', [:])
        BUNDLE_EXTRACT_JAR = null
        if (CONFIG.containsKey('bundler_extract_jar'))
            BUNDLE_EXTRACT_JAR = Utils.readConfig(CONFIG, 'bundler_extract_jar', [:])
        BUNDLE_EXTRACT_LIBS = null
        if (CONFIG.containsKey('bundler_extract_libs'))
            BUNDLE_EXTRACT_LIBS = Utils.readConfig(CONFIG, 'bundler_extract_libs', [:])
    }
    final boolean MERGE_PATCHES = !rootProject.hasProperty('updating') && CONFIG.get('merge_patches', false)

    java.toolchain.languageVersion = JavaLanguageVersion.of(JAVA_TARGET)

    configurations {
        srgutilsJar
    }

    repositories {
        maven {
            name 'forge'
            url 'https://maven.minecraftforge.net/'
        }
    }

    dependencies {
        srgutilsJar "net.minecraftforge:srgutils:${SRGUTILS_VERSION}"
    }

    final File downloadJsonDest = file(PATH_CACHED_VERSION + 'version.json')
    tasks.register('downloadJson', Download) {
        dependsOn ':downloadVersionManifest'
        inputs.file downloadVersionManifestDest
        src { downloadVersionManifestDest.json.versions.find { it.id == project.name }.url }
        dest downloadJsonDest
        useETag 'all'
        onlyIfModified true
        quiet true
    }

    final File downloadClientDest = file(PATH_CACHED_VERSION + 'client.jar')
    tasks.register('downloadClient', Download) {
        dependsOn 'downloadJson'
        inputs.file downloadJsonDest
        src { downloadJsonDest.json.downloads.get('client').url }
        dest downloadClientDest
        useETag 'all'
        onlyIfModified true
        quiet true
    }

    final File downloadServerDest = file(PATH_CACHED_VERSION + 'server.jar')
    tasks.register('downloadServer', Download) {
        dependsOn 'downloadJson'
        inputs.file downloadJsonDest
        src { downloadJsonDest.json.downloads.get('server').url }
        dest downloadServerDest
        useETag 'all'
        onlyIfModified true
        quiet true
    }

    final File downloadClientMappingsDest = file(PATH_CACHED_VERSION + 'client_mappings.txt')
    tasks.register('downloadClientMappings', Download) {
        dependsOn 'downloadJson'
        inputs.file downloadJsonDest
        src { downloadJsonDest.json.downloads.get('client_mappings').url }
        dest downloadClientMappingsDest
        useETag 'all'
        onlyIfModified true
        quiet true
    }

    final File downloadServerMappingsDest = file(PATH_CACHED_VERSION + 'server_mappings.txt')
    tasks.register('downloadServerMappings', Download) {
        dependsOn 'downloadJson'
        inputs.file downloadJsonDest
        src { downloadJsonDest.json.downloads.get('server_mappings').url }
        dest downloadServerMappingsDest
        useETag 'all'
        onlyIfModified true
        quiet true
    }

    tasks.register('downloadLibraries', DownloadLibraries) {
        dependsOn 'downloadJson', 'downloadBundleExtractorLibs', 'downloadBundleExtractorJar', 'downloadRenameTool', 'downloadFernflower', 'downloadMergeTool'
        json = downloadJsonDest
        config = CONFIG
        dest = file(PATH_CACHED_LIBRARIES)
    }

    tasks.register('downloadFernflower', DownloadTool) {
        config FERNFLOWER, PATH_CACHED_LIBRARIES
    }
    tasks.register('downloadMergeTool', DownloadTool) {
        config MERGETOOL, PATH_CACHED_LIBRARIES
    }
    tasks.register('downloadRenameTool', DownloadTool) {
        config RENAMETOOL, PATH_CACHED_LIBRARIES
    }

    final File downloadAssetsDest = file(PATH_BUILD + '/assets/')
    tasks.register('downloadAssets', DownloadAssets) {
        dependsOn 'downloadJson'
        json = downloadJsonDest
        dest = downloadAssetsDest
    }

    final File makeEmptyFileDest = file(PATH_BUILD + '/empty.txt')
    if (MCINJECTOR != null) {
        tasks.register('downloadMCInjector', DownloadTool) {
            config MCINJECTOR, PATH_CACHED_LIBRARIES
        }
        tasks.register('makeEmptyFile', SingleFileOutput) {
            dest makeEmptyFileDest
            doLast {
                dest.text = ''
            }
        }
    }

    final File extractServerDest = file(PATH_CACHED_VERSION + 'server.extracted.jar')
    final File extractServerLibrariesDest = file(PATH_CACHED_VERSION + 'server_libraries')
    if (BUNDLE_EXTRACT_JAR != null) {
        tasks.register('downloadBundleExtractorJar', DownloadTool) {
            config BUNDLE_EXTRACT_JAR, PATH_CACHED_LIBRARIES
        }
        tasks.register('downloadBundleExtractorLibs', DownloadTool) {
            config BUNDLE_EXTRACT_LIBS, PATH_CACHED_LIBRARIES
        }
        tasks.register('extractServer', ExtractBundleJar) {
            dependsOn 'downloadBundleExtractorJar', 'downloadBundleExtractorLibs', 'downloadServer'
            config BUNDLE_EXTRACT_JAR, tasks.downloadBundleExtractorJar
            input = downloadServerDest
            dest = extractServerDest
        }
        tasks.register('extractServerLibraries', ExtractBundleLibs) {
            dependsOn 'downloadBundleExtractorJar', 'downloadBundleExtractorLibs', 'downloadServer'
            config BUNDLE_EXTRACT_LIBS, tasks.downloadBundleExtractorLibs
            input = downloadServerDest
            dest = extractServerLibrariesDest
        }
    }

    final File filterClientSlim = file(PATH_CACHED_VERSION + 'client.slim.jar')
    final File filterClientExtra = file(PATH_CACHED_VERSION + 'client.extra.jar')
    tasks.register('filterClient', SplitJar) {
        dependsOn 'downloadClient'
        mappings = file('joined.tsrg')
        source = downloadClientDest
        slim = filterClientSlim
        extra = filterClientExtra
    }

    final File filterServerSlim = file(PATH_CACHED_VERSION + 'server.slim.jar')
    final File filterServerExtra = file(PATH_CACHED_VERSION + 'server.extra.jar')
    tasks.register('filterServer', SplitJar) {
        dependsOn BUNDLE_EXTRACT_JAR == null ? ['downloadServer'] : ['extractServer']
        mappings = file('joined.tsrg')
        source = BUNDLE_EXTRACT_JAR == null ? downloadServerDest : extractServerDest
        slim = filterServerSlim
        extra = filterServerExtra
    }

    task mergeJars(type: MergeJar, dependsOn: ['downloadMergeTool', 'filterClient', filterServer]) {
        config MERGETOOL, tasks.downloadMergeTool
        classpath = configurations.srgutilsJar
        classpath.from project.files(downloadMergeTool)
        mainClass = 'net.minecraftforge.mergetool.ConsoleMerger'
        client filterClientSlim
        server filterServerSlim
        version project.version
        dest file(PATH_CACHED_VERSION + 'joined.jar')
    }

    final File makeObfToIntermediateDest = file(PATH_CACHED_VERSION + 'obf_to_intermediate.tsrg')
    tasks.register('makeObfToIntermediate', RenameMappings) {
        dependsOn 'downloadClientMappings'
        intermediate = file('joined.tsrg')
        if (CONFIG.official)
            official = downloadClientMappingsDest
        dest = makeObfToIntermediateDest
    }

    def sides = [
        client: [Name: 'Client', jsonlibs: true,  assets: true,  slim: tasks.filterClient, extra: tasks.filterClient, bundle: null],
        server: [Name: 'Server', jsonlibs: false, assets: false, slim: tasks.filterServer, extra: tasks.filterServer, bundle: downloadServer],
        joined: [Name: 'Joined', jsonlibs: true,  assets: true,  slim: mergeJars,          extra: tasks.filterClient, bundle: null]
    ]

    for (def sidesEntry in sides.entrySet()) {
        final String s = sidesEntry.key
        final var child = sidesEntry.value

        child.libraries = tasks.create("fernflowerLibraries${child.Name}", CreateFernflowerLibraries) {
            dependsOn 'downloadLibraries', 'downloadJson', child.slim
            if (BUNDLE_EXTRACT_LIBS !== null)
                dependsOn 'extractServerLibraries'

            meta = downloadJsonDest
            config = CONFIG
            side = s
            root = PATH_CACHED_LIBRARIES
            doFirst {
                if (s == 'server') {
                    extras += [tasks.filterServer.extra]
                    if (BUNDLE_EXTRACT_LIBS != null)
                        extractServerLibrariesDest.eachFileRecurse(groovy.io.FileType.FILES) { file -> extras += [file] }
                }
            }
            dest = file(PATH_CACHED_VERSION + s + '.fernflower.libs.txt')
        }

        child.renameDest = file(PATH_CACHED_VERSION + s + '.mapped.jar')
        child.rename = tasks.register("rename${child.Name}", RemapJar) {
            dependsOn 'downloadRenameTool', child.slim, 'makeObfToIntermediate', child.libraries
            config RENAMETOOL, downloadRenameTool
            input = s == 'joined' ? child.slim.dest : child.slim.slim
            mappings = makeObfToIntermediateDest
            libraries = child.libraries.dest
            dest = child.renameDest
            log = file(PATH_CACHED_VERSION + s + '.mapped.log')
        }

        if (MCINJECTOR != null) {
            final OutputStream NULL_OUTPUT = new OutputStream() { void write(int b) {} }
            child.mcinject = tasks.create("mcinject${child.Name}", MCInjectTask) {
                dependsOn 'downloadMCInjector', child.rename, 'makeEmptyFile'//, makeExceptions, fixAccessLevels
                config MCINJECTOR, downloadMCInjector
                access = makeEmptyFileDest //fixAccessLevels.dest
                constructors = project.file('constructors.txt')
                exceptions = makeEmptyFileDest //makeExceptions.dest
                standardOutput = NULL_OUTPUT
                log = file(PATH_CACHED_VERSION + s + '.mci.log')
                input = child.renameDest
                dest = file(PATH_CACHED_VERSION + s + '.mci.jar')
            }
        }
    }

    tasks.register('renameJars') { dependsOn renameClient, renameServer, renameJoined }

    final File extractInheritanceDest = file(PATH_CACHED_VERSION_DATA + 'inheritance.json')
    tasks.register('extractInheritance', ExtractInheritance) {
        dependsOn 'downloadLibraries', mergeJars
        input mergeJars.dest
        inputs.file downloadJsonDest
        dest extractInheritanceDest
        doFirst {
            downloadJsonDest.json.libraries.stream().map { it?.downloads?.artifact?.path }.findAll { it !== null }.each { library(file(PATH_CACHED_LIBRARIES + it)) }
        }
    }
    tasks.register('extractInheritanceNamed', ExtractInheritance) {
        dependsOn renameJoined
        input renameJoined.dest
        inputs.file downloadJsonDest
        dest file(PATH_CACHED_VERSION_DATA + 'inheritance_named.json')
        doFirst {
            downloadJsonDest.json.libraries.stream().map { it?.downloads?.artifact?.path }.findAll { it !== null }.each { library(file(PATH_CACHED_LIBRARIES + it)) }
        }
    }

    tasks.register('dumpOverrides', DumpOverrides) {
        dependsOn 'extractInheritance', 'makeObfToIntermediate'
        srg makeObfToIntermediateDest
        meta extractInheritanceDest
        dest file(PATH_CACHED_VERSION_DATA + 'overrides.txt')
    }

    tasks.register('projectRoot', Copy) {
        from rootProject.file('templates/root_settings.gradle')
        into file('projects/')
        rename { 'settings.gradle' }
        expand([version: project.name])
    }

    final File extractNativesDest = file(PATH_NATIVES)
    tasks.register('extractNatives', ExtractNatives) {
        dependsOn 'downloadJson', 'downloadLibraries', 'downloadRenameTool', 'downloadFernflower',
                'downloadBundleExtractorLibs', 'downloadBundleExtractorJar', 'downloadMergeTool'
        meta downloadJsonDest
        cache file(PATH_CACHED_LIBRARIES)
        dest extractNativesDest
    }

    tasks.register('verify', VerifyMappings) {
        dependsOn mergeJars, 'makeObfToIntermediate'
        mappings = makeObfToIntermediateDest
        joined = mergeJars.dest
        o2s2idMappings = file('joined.tsrg')
    }

    tasks.register('decompileAll')
    tasks.register('projectAll')
    tasks.register('projectDeleteAll')
    tasks.register('projectResetAll')
    tasks.register('projectApplyAll')
    tasks.register('projectMakeAll')

    tasks.register('testDecompile')
    tasks.register('testCompile')
    //tasks.register('testApi')
    tasks.register('testJdks') {
        dependsOn 'testDecompile', 'testCompile'//, testApi
    }

    for (def sidesEntry in sides.entrySet()) {
        final String side = sidesEntry.key
        final var child = sidesEntry.value

        // Normal workflow tasks
        child.decompileDest = file(PATH_CACHED_VERSION + side + '.decompile.jar')
        child.decompile = tasks.register("decompile${child.Name}", FernflowerTask) {
            dependsOn /*verify,*/ 'downloadFernflower', child.rename, child.libraries
            if (MCINJECTOR !== null)
                dependsOn child.mcinject

            config FERNFLOWER, downloadFernflower
            libraries = child.libraries.dest
            input = MCINJECTOR != null ? child.mcinject.dest : child.renameDest
            log = file(PATH_CACHED_VERSION + side + '.decompile.log')
            dest = child.decompileDest

        }
        tasks.named('decompileAll').configure {
            dependsOn child.decompile
        }

        child.pkgsDest = file(PATH_CACHED_VERSION + side + '.pkgs.jar')
        child.pkgs = tasks.register("create${child.Name}PackageInfos", MakePackageInfos) {
            dependsOn child.decompile
            input = child.decompileDest
            template = PATH_INJECT_TEMPLATE.exists() ? PATH_INJECT_TEMPLATE : null
            dest = child.pkgsDest
        }
    }

    if (MERGE_PATCHES) {
        task deduplicateSources(type: DeduplicateJars, dependsOn: [sides.client.decompile, sides.server.decompile, sides.joined.decompile]) {
            clientIn = sides.client.decompileDest
            serverIn = sides.server.decompileDest
            joinedIn = sides.joined.decompileDest
            duplicates = file(PATH_CACHED_VERSION + 'source.duplicates.jar')
            sides.client.slimsrc = clientOut = file(PATH_CACHED_VERSION + 'client.decompile.slim.jar')
            sides.server.slimsrc = serverOut = file(PATH_CACHED_VERSION + 'server.decompile.slim.jar')
            sides.joined.slimsrc = joinedOut = file(PATH_CACHED_VERSION + 'joined.decompile.slim.jar')
        }

        tasks.register('projectSharedMakeDir') {
            doLast {
                mkdir projectSharedReset.target
            }
        }
        tasks.register('projectSharedMakePatchesDir') {
            doLast {
                mkdir projectSharedApplyPatches.patches
            }
        }

        task projectSharedReset(type: ResetSourcesTask, dependsOn: [deduplicateSources, 'projectSharedMakeDir', 'projectRoot']) {
            rootZip deduplicateSources.duplicates
            target project.file('projects/shared')
        }
        task projectSharedApplyPatches(type: ApplyPatchesTask, dependsOn: [projectSharedReset, 'projectSharedMakePatchesDir', 'projectRoot']) {
            target projectSharedReset.target
            patches project.file('patches/shared')
        }
        task projectSharedMakePatches(type: MakePatchesTask, dependsOn: deduplicateSources) {
            rootZip deduplicateSources.duplicates
            target projectSharedApplyPatches.target
            patches projectSharedApplyPatches.patches
        }
        task renameSourcesShared(type: RenameSources, dependsOn: [projectSharedApplyPatches, 'makeObfToIntermediate', 'downloadClientMappings']) {
            input = projectSharedApplyPatches.target
            srg = makeObfToIntermediateDest
            official = downloadClientMappingsDest
            dest = project.file(PATH_CACHED_VERSION + "test/official/shared/src/")
        }
    }

    for (def sidesEntry in sides.entrySet()) {
        final String side = sidesEntry.key
        final var child = sidesEntry.value

        final File project_dir = project.file("projects/${side}")
        final File patches_dir = project.file("patches/${side}")
        
        child.delete = tasks.register("project${child.Name}Delete", Delete) {
            delete project_dir
        }
        tasks.named('projectDeleteAll').configure {
            dependsOn child.delete
        }
        
        child.project = task "project${child.Name}"(type: CreateProjectTemplate, dependsOn: ['projectRoot', child.extra, child.decompile, child.pkgs] +
                (child.jsonlibs ? ['downloadJson', 'extractNatives'] : []) +
                (child.assets ? ['downloadAssets'] : []) +
                (child.bundle != null ? [child.bundle] : [])
        ) {
            mustRunAfter child.delete
            dest project_dir
            distro side
            template rootProject.file('templates/build.gradle')
            if (child.jsonlibs)
                meta downloadJsonDest
            if (child.bundle != null)
                bundle = child.bundle.dest
            CONFIG?.libraries?.get(side)?.each { library "'${it}'" }
            libraryFile child.extra.extra
            replace '{java_target}', JAVA_TARGET + ''
            replaceFile '{inject}', PATH_INJECT
            replaceFile '{assets}', child.assets ? downloadAssetsDest : null
            replaceFile '{natives}', child.jsonlibs ? extractNativesDest : null
            replaceFile '{merged_src}', MERGE_PATCHES ? projectSharedReset.target : null
        }
        tasks.named('projectAll').configure {
            dependsOn child.project
        }

        final File resetPkgsTarget = new File(project_dir, 'src/pkginfo/java')
        child.resetPkgs = tasks.register("project${child.Name}ResetPackages", ResetSourcesTask) {
            dependsOn child.makePkgsDir, child.pkgs
            mustRunAfter child.project
            rootZip child.pkgsDest
            target resetPkgsTarget
        }
        child.makePkgsDir = tasks.register("project${child.Name}MakePkgsDir") {
            doLast {
                mkdir resetPkgsTarget
            }
        }

        final File resetTarget = new File(project_dir, 'src/main/java')
        child.reset = tasks.register("project${child.Name}Reset", ResetSourcesTask) {
            dependsOn child.resetPkgs, child.makeSrcDir, child.project, child.decompile
            if (MERGE_PATCHES)
                dependsOn projectSharedReset

            mustRunAfter child.project
            rootZip MERGE_PATCHES ? child.slimsrc : child.decompileDest
            target resetTarget
        }
        child.makeSrcDir = tasks.register("project${child.Name}MakeSrcDir") {
            doLast {
                mkdir resetTarget
            }
        }

        tasks.named('projectResetAll').configure {
            dependsOn child.reset
        }
        
        child.makePatchesDir = tasks.register("project${child.Name}MakePatchesDir") {
            doLast {
                mkdir patches_dir
            }
        }

        child.apply = tasks.register("project${child.Name}ApplyPatches", ApplyPatchesTask) {
            dependsOn child.reset, child.makePatchesDir
            if (MERGE_PATCHES)
                dependsOn projectSharedApplyPatches

            target new File(project_dir, 'src/main/java')
            patches patches_dir
        }
        tasks.named('projectApplyAll').configure {
            dependsOn child.apply
        }

        child.makePatches = tasks.register("project${child.Name}MakePatches", MakePatchesTask) {
            if (MERGE_PATCHES)
                dependsOn deduplicateSources, projectSharedMakePatches
            else
                dependsOn child.decompile

            rootZip MERGE_PATCHES ? child.slimsrc : child.decompileDest
            target new File(project_dir, 'src/main/java')
            patches patches_dir
        }
        tasks.named('projectMakeAll').configure {
            dependsOn child.makePatches
        }

        child.renameSourcesInput = new File(project_dir, 'src/main/java')
        child.renameSourcesDest = project.file(PATH_CACHED_VERSION + "test/official/${side}/src/")
        child.renameSources = tasks.register("renameSources${child.Name}", RenameSources) {
            dependsOn child.apply, 'makeObfToIntermediate', 'downloadClientMappings'
            if (MERGE_PATCHES)
                dependsOn renameSourcesShared

            input = child.renameSourcesInput
            srg = makeObfToIntermediateDest
            official = downloadClientMappingsDest
            dest = child.renameSourcesDest
        }
        
        // Tests
        final TaskProvider<Task> testDecompileSide = tasks.register("testDecompile${child.Name}")
        tasks.named('testDecompile').configure {
            dependsOn testDecompileSide
        }
        final TaskProvider<Task> testCompileSide = tasks.register("testCompile${child.Name}")
        tasks.named('testCompile').configure {
            dependsOn testCompileSide
        }
        /*
        def testApiSide = task("testApi${child.Name}")
        tasks.named('testApi').configure {
            dependsOn testApiSide
        }
        */
        
        def jdks = [
            [name: 'hotspot8',   Name: 'HotSpot8',   version: 8,  official: false],
            [name: 'hotspot11',  Name: 'HotSpot11',  version: 11, official: false],
            [name: 'hotspot15',  Name: 'HotSpot15',  version: 15, official: false],
            [name: 'hotspot16',  Name: 'HotSpot16',  version: 16, official: false],
            [name: 'hotspot17',  Name: 'HotSpot17',  version: 17, official: false],
            [name: 'hotspot18',  Name: 'HotSpot18',  version: 18, official: false],
            [name: 'hotspot19',  Name: 'HotSpot19',  version: 19, official: false],
            [name: 'hotspot20',  Name: 'HotSpot20',  version: 20, official: false],
            [name: 'official8',  Name: 'Official8',  version: 8,  official: true ],
            [name: 'official16', Name: 'Official16', version: 16, official: true ],
            [name: 'official17', Name: 'Official17', version: 17, official: true ],
            [name: 'official18', Name: 'Official18', version: 18, official: true ],
            [name: 'official19', Name: 'Official19', version: 19, official: true ],
            [name: 'official20', Name: 'Official20', version: 20, official: true ]
        ]
        jdks.findAll { it.version >= JAVA_TARGET }.each { jdk ->
            final File testPath = project.file(PATH_CACHED_VERSION + 'test/' + jdk.name + '/')

            final File tstDecompileDest = new File(testPath, side + '.decompile.jar')
            var tstDecompile = tasks.register("testDecompile${child.Name}${jdk.Name}", FernflowerTask) {
                dependsOn 'downloadFernflower', child.rename, child.libraries
                config FERNFLOWER, downloadFernflower
                javaLauncher = javaToolchains.launcherFor {
                    languageVersion = JavaLanguageVersion.of(jdk.version)
                }
                libraries = child.libraries.dest
                input = child.renameDest
                log = new File(testPath, side + '.decompile.log')
                dest = tstDecompileDest
            }

            var tstDecompileCheck = tasks.register("testDecompile${child.Name}${jdk.Name}Compare", CompareJars) {
                dependsOn tstDecompile, child.decompile
                expected = child.decompileDest
                actual = tstDecompileDest
            }
            testDecompileSide.configure {
                dependsOn tstDecompileCheck
            }
            
            var tstCompileClean = tasks.register("testCompile${child.Name}${jdk.Name}Clean", Delete) {
                delete new File(testPath, 'classes')
            }
            
            File sourceDir = jdk.official ? child.renameSourcesDest : child.renameSourcesInput
            def sharedDir = MERGE_PATCHES ? (jdk.official ? renameSourcesShared.dest : renameSourcesShared.input) : null
            
            var tstCompile = tasks.register("testCompile${child.Name}${jdk.Name}", JavaCompile) {
                dependsOn child.apply, tstCompileClean
                if (jdk.official)
                    dependsOn child.renameSources

                javaCompiler = javaToolchains.compilerFor {
                    languageVersion = JavaLanguageVersion.of(jdk.version)
                }
                source = project.files(sourceDir)
                if (sharedDir !== null)
                    source += project.files(sharedDir)

                destinationDirectory = new File(testPath, 'classes')
                options.warnings = false
                options.encoding = ENCODING
                sourceCompatibility = targetCompatibility = JAVA_TARGET <= 8 ? '1.' + JAVA_TARGET : JAVA_TARGET.toString()
                // JavaCompile task type requires classpath to be specified before the task begins execution
                // but the data isn't generated yet, so instead - inject the classpath as the first thing done when it begins
                classpath = files()
                options.fork = true
                doFirst {
                    classpath = files(Files.readAllLines(child.libraries.dest.toPath()).collect { file(it.substring(3)) }) // skip "-e="
                }
            }
            testCompileSide.configure {
                dependsOn tstCompile
            }
            
            /*
            def tstApi = task "testApi${child.Name}${jdk.Name}"(type: CheckAPI, dependsOn: [tstCompile, rootProject.extractRuntimeApi]) {
                input = tstCompile.destinationDir
                //apis.add(rootProject.extractRuntimeApi.dest)
                dest new File(testPath, 'api_errors.json')
            }
            testApiSide.dependsOn(tstApi)
            */
        }
    }

    tasks.register('generateConfiguration', SingleFileOutput) {
        inputs.property('config', CONFIG)
        dest file(PATH_CACHED_VERSION_DATA + 'config.json')

        doLast {
            var json = new JsonBuilder()

            if (CONFIG.official) {
                var steps_def = [
                    joined: [
                        [type: 'downloadManifest'],
                        [type: 'downloadJson'],
                        [type: 'downloadClient'],
                        [type: 'downloadServer'],
                        [type: 'downloadClientMappings'],
                        [type: 'mergeMappings', official: '{downloadClientMappingsOutput}'],
                        [type: 'strip', name: 'stripClient', input: '{downloadClientOutput}'],
                        [type: 'strip', name: 'stripServer', input: '{downloadServerOutput}'],
                        [type: 'merge', client: '{stripClientOutput}', server: '{stripServerOutput}', version: project.version],
                        [type: 'listLibraries'],
                        [type: 'rename', input: '{mergeOutput}', libraries: '{listLibrariesOutput}', mappings: '{mergeMappingsOutput}'],
                        [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{renameOutput}'],
                        [type: 'inject', input: '{decompileOutput}'],
                        [type: 'patch', input: '{injectOutput}']
                    ],
                    client: [
                        [type: 'downloadManifest'],
                        [type: 'downloadJson'],
                        [type: 'downloadClient'],
                        [type: 'downloadClientMappings'],
                        [type: 'mergeMappings', official: '{downloadClientMappingsOutput}'],
                        [type: 'strip', input: '{downloadClientOutput}'],
                        [type: 'listLibraries'],
                        [type: 'rename', input: '{stripOutput}', libraries: '{listLibrariesOutput}', mappings: '{mergeMappingsOutput}'],
                        [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{renameOutput}'],
                        [type: 'inject', input: '{decompileOutput}'],
                        [type: 'patch', input: '{injectOutput}']
                    ],
                    server: [
                        [type: 'downloadManifest'],
                        [type: 'downloadJson'],
                        [type: 'downloadServer'],
                        [type: 'downloadClientMappings'],
                        [type: 'mergeMappings', official: '{downloadClientMappingsOutput}'],
                        [type: 'strip', input: '{downloadServerOutput}'],
                        [type: 'listLibraries'],
                        [type: 'rename', input: '{stripOutput}', libraries: '{listLibrariesOutput}', mappings: '{mergeMappingsOutput}'],
                        [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{renameOutput}'],
                        [type: 'inject', input: '{decompileOutput}'],
                        [type: 'patch', input: '{injectOutput}']
                    ]
                ]

                final Closure<Boolean> keyIsNotPath = { it.key != 'path' }
                Map<String, Collection> functions_def = [
                    decompile: FERNFLOWER.findAll(keyIsNotPath),
                    merge:     MERGETOOL .findAll(keyIsNotPath),
                    rename:    RENAMETOOL.findAll(keyIsNotPath),
                    mergeMappings: MERGEMAPTOOL.findAll(keyIsNotPath)
                ]
                int specVer = 2

                if (BUNDLE_EXTRACT_JAR != null) {
                    specVer = 3 // Spec v3 adds 'bundle' to the listLibraries task. 
                    functions_def['bundleExtractJar'] = BUNDLE_EXTRACT_JAR.findAll {it.key != 'path'}
                    steps_def['joined'].add(4, [name: 'extractServer', type: 'bundleExtractJar', input: '{downloadServerOutput}'])
                    steps_def['joined'].find{'stripServer'.equals(it.name) }['input'] = '{extractServerOutput}'

                    steps_def['server'].add(3, [name: 'extractServer', type: 'bundleExtractJar', input: '{downloadServerOutput}'])
                    steps_def['server'].find{'strip'.equals(it.type) }['input'] = '{extractServerOutput}'
                    steps_def['server'].find{'listLibraries'.equals(it.type) }['bundle'] = '{downloadServerOutput}'
                }

                if (functions_def.values().any { it.java_version != null }) {
                    specVer = 4 // Spec v4 adds the ability to set a java version to run a tool with
                }

                json {
                    spec specVer
                    version project.version
                    official CONFIG.official
                    java_target JAVA_TARGET
                    encoding ENCODING
                    data {
                        mappings 'config/joined.tsrg'
                        inject 'config/inject/'
                        patches {
                            client 'patches/client/'
                            joined 'patches/joined/'
                            server 'patches/server/'
                        }
                    }
                    steps steps_def
                    functions functions_def
                    libraries CONFIG.libraries
                }
            } else {
                def steps_def = [
                    joined: [
                        [type: 'downloadManifest'],
                        [type: 'downloadJson'],
                        [type: 'downloadClient'],
                        [type: 'downloadServer'],
                        [type: 'strip', name: 'stripClient', input: '{downloadClientOutput}'],
                        [type: 'strip', name: 'stripServer', input: '{downloadServerOutput}'],
                        [type: 'merge', client: '{stripClientOutput}', server: '{stripServerOutput}', version: project.version],
                        [type: 'rename', input: '{mergeOutput}'],
                        [type: 'mcinject', input: '{renameOutput}'],
                        [type: 'listLibraries'],
                        [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{mcinjectOutput}'],
                        [type: 'inject', input: '{decompileOutput}'],
                        [type: 'patch', input: '{injectOutput}']
                    ],
                    client: [
                        [type: 'downloadManifest'],
                        [type: 'downloadJson'],
                        [type: 'downloadClient'],
                        [type: 'strip', input: '{downloadClientOutput}'],
                        [type: 'rename', input: '{stripOutput}'],
                        [type: 'mcinject', input: '{renameOutput}'],
                        [type: 'listLibraries'],
                        [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{mcinjectOutput}'],
                        [type: 'inject', input: '{decompileOutput}'],
                        [type: 'patch', input: '{injectOutput}']
                    ],
                    server: [
                        [type: 'downloadManifest'],
                        [type: 'downloadJson'],
                        [type: 'downloadServer'],
                        [type: 'strip', input: '{downloadServerOutput}'],
                        [type: 'rename', input: '{stripOutput}'],
                        [type: 'mcinject', input: '{renameOutput}'],
                        [type: 'listLibraries'],
                        [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{mcinjectOutput}'],
                        [type: 'inject', input: '{decompileOutput}'],
                        [type: 'patch', input: '{injectOutput}']
                    ]
                ]
                json {
                    spec 1
                    version project.version
                    data {
                        access 'config/access.txt'
                        constructors 'config/constructors.txt'
                        exceptions 'config/exceptions.txt'
                        mappings 'config/joined.tsrg'
                        inject 'config/inject/'
                        statics 'config/static_methods.txt'
                        patches {
                            client 'patches/client/'
                            joined 'patches/joined/'
                            server 'patches/server/'
                        }
                    }
                    steps steps_def
                    functions {
                        decompile CONFIG.fernflower
                        mcinject CONFIG.mcinjector
                        merge CONFIG.merge
                        rename CONFIG.rename
                    }
                    libraries CONFIG.libraries
                }
            }
            dest.text = groovy.json.JsonOutput.prettyPrint(json.toString())
        }
    }

    task makeZip(type: Zip, dependsOn: ['generateConfiguration']) {
        archiveBaseName = rootProject.name
        archiveVersion = project.version
        destinationDirectory = file(PATH_BUILD + '/distributions')

        from tasks.generateConfiguration
        from(file('joined.tsrg')){ into 'config/' }

        var patches = file('patches')
        if (patches.exists()) {
            var shared = file('patches/shared')
            if (MERGE_PATCHES && shared.exists()) {
                for (def side : ['client', 'server', 'joined']) {
                    from(file('patches/' + side)) {
                        into 'patches/' + side
                    }
                    from(shared) {
                        into 'patches/' + side
                    }
                }
            } else {                
                from(patches) {
                    into 'patches/'
                }
            }
        }

        if (PATH_INJECT != null && PATH_INJECT.exists()) {
            from(PATH_INJECT) {
                into 'config/inject/'
            }
        }
    }

    publishing {
        publications {
            if (!rootProject.hasProperty('timed_only') && (MC_VERSION.compareTo(MC_1_16_5) > 0 || !CONFIG.official)) {
                register('normal', MavenPublication) {
                    artifactId rootProject.name
                    artifact makeZip
                    pom {
                        name = 'MCPConfig'
                        description = 'Configuration files used for deobfuscating and modding Minecraft.'
                        url = 'https://github.com/MinecraftForge/MCPConfig'
                        scm {
                            url = 'https://github.com/MinecraftForge/MCPConfig'
                            connection = 'scm:git:git://github.com/MinecraftForge/MCPConfig.git'
                            developerConnection = 'scm:git:git@github.com:MinecraftForge/MCPConfig.git'
                        }
                        issueManagement {
                            system = 'github'
                            url = 'https://github.com/MinecraftForge/MCPConfig/issues'
                        }

                        licenses {
                            license {
                                name = 'All Rights Reserved, No redistribution.'
                                url = ''
                            }
                        }
                    }
                }
            }
            register('timed', MavenPublication) {
                artifactId rootProject.name
                version project.version + '-' + TIMESTAMP
                artifact makeZip
                pom {
                    name = 'MCPConfig'
                    description = 'Configuration files used for deobfuscating and modding Minecraft.'
                    url = 'https://github.com/MinecraftForge/MCPConfig'
                    scm {
                        url = 'https://github.com/MinecraftForge/MCPConfig'
                        connection = 'scm:git:git://github.com/MinecraftForge/MCPConfig.git'
                        developerConnection = 'scm:git:git@github.com:MinecraftForge/MCPConfig.git'
                    }
                    issueManagement {
                        system = 'github'
                        url = 'https://github.com/MinecraftForge/MCPConfig/issues'
                    }

                    licenses {
                        license {
                            name = 'All Rights Reserved, No redistribution.'
                            url = ''
                        }
                    }
                }
            }
        }
        repositories {
            maven {
                if (rootProject.hasProperty('MAVEN_USER') && rootProject.hasProperty('MAVEN_PASSWORD') && rootProject.hasProperty('MAVEN_URL')) {
                    url rootProject.getProperty('MAVEN_URL')
                    authentication {
                        basic(BasicAuthentication)
                    }
                    credentials {
                        username = rootProject.getProperty('MAVEN_USER') ?: 'not'
                        password = rootProject.getProperty('MAVEN_PASSWORD') ?: 'set'
                    }
                } else {
                    url 'file://' + rootProject.file('repo').getAbsolutePath()
                }
            }
        }
    }
}

int getVersionIndex(String prop, int default_) {
    if (!project.hasProperty(prop))
        return default_
    if (!VERSIONS.contains(project.getProperty(prop)))
        throw new IllegalArgumentException('Unknown version in ' + prop + ': ' + project.getProperty(prop) + ' Known: ' + VERSIONS.toString())
    return VERSIONS.indexOf(project.getProperty(prop))
}

var template = project(':' + VERSIONS[0])
final int start = getVersionIndex('startVersion', 0)
final int end = getVersionIndex('endVersion', VERSIONS.size - 1)

if (start > end)
    throw new IllegalArgumentException('Invalid start and end range: ' + VERSIONS[start] + ' > ' + VERSIONS[end])

template.tasks.each { t ->
    var myTask
    try {
        myTask = tasks.named(t.name)
    } catch (UnknownTaskException ignored) {
        myTask = tasks.register(t.name)
    }
    for (int x = start; x <= end; x++) {
        try {
            var task = project(VERSIONS[x]).tasks.named(t.name)
            myTask.configure {
                dependsOn task
            }
        } catch (UnknownTaskException ignored) {}
    }
}
