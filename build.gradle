buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        maven { url = 'https://files.minecraftforge.net/maven/'}
        maven { url = 'https://plugins.gradle.org/m2/' }
    }
    dependencies {
        classpath 'net.minecraftforge:srgutils:0.3.1'
    }
}

plugins {
    id 'de.undercouch.download'
    id 'uk.jamierocks.propatcher' version '1.3.2' apply false
}

import net.minecraftforge.mcpconfig.tasks.*
import net.minecraftforge.srgutils.MinecraftVersion
import uk.jamierocks.propatcher.task.*

group = 'de.oceanlabs.mcp'

net.minecraftforge.mcpconfig.tasks.Utils.init()

ext {
    MC_1_16_5 = MinecraftVersion.from('1.16.5')
    VERSIONS = subprojects.collect{it.name}.sort{ a,b -> MinecraftVersion.from(a).compareTo(MinecraftVersion.from(b)) } as List
    NULL_OUPUT = new OutputStream() { public void write(int b){} }
    TIMESTAMP = (new Date()).format('yyyyMMdd.HHmmss')
    PATH_BUILD = file('build').absolutePath
}

logger.lifecycle('Timestamp: ' + TIMESTAMP)

/* Tasks to download the launcher metadata as well as the offical runtime shipped by Mojang. *
 * This allows us to verify that our recompiled code will work on the official runtime.      */
task downloadVersionManifest(type: Download) {
    src 'https://launchermeta.mojang.com/mc/game/version_manifest_v2.json'
    dest file('build/versions/version_manifest.json')
    useETag 'all'
    onlyIfModified true
    quiet true
}

task downloadLauncherManifest(type: Download) {
    src 'https://launchermeta.mojang.com/mc/launcher.json'
    dest file('build/versions/launcher.json')
    useETag 'all'
    onlyIfModified true
    quiet true
}

task downloadRuntime(type: Download, dependsOn: downloadLauncherManifest) {
    src { downloadLauncherManifest.dest.json.windows.get('64').jdk.url }
    dest file('build/win_64_runtime.lzma')
    useETag 'all'
    onlyIfModified true
    quiet true
}

task extractRuntimeApi(type: ExtractAPI, dependsOn: downloadRuntime) {
    archive = downloadRuntime.dest
    dest = file('build/runtime_api.json')
}

if (project.hasProperty('old_version') && project.hasProperty('new_version')) {
    println('Update Old: ' + project.getProperty('old_version') + ' New: ' + project.getProperty('new_version'))
    apply from: 'update.gradle'
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'de.undercouch.download'
    apply plugin: 'maven-publish'
    
    group = rootProject.group
    version = name

    ext {
        MC_VERSION = MinecraftVersion.from(project.name)
        PATH_CACHED_LIBRARIES = PATH_BUILD + '/libraries/'
        PATH_CACHED_VERSION = PATH_BUILD + '/versions/' + project.version + '/'
        PATH_CACHED_VERSION_DATA = PATH_CACHED_VERSION + 'data/'
        
        PATH_INJECT = file('inject')
        PATH_INJECT_TEMPLATE = new File(PATH_INJECT, 'package-info-template.java')
        PATH_NATIVES = file('projects/natives')

        CONFIG = file('config.json').json
        JAVA_TARGET = CONFIG.get('java_target', 8)
        ENCODING = CONFIG.get('encoding', 'UTF-8')
        FERNFLOWER = Utils.readConfig(CONFIG, 'fernflower', [:])        
        MERGETOOL = Utils.readConfig(CONFIG, 'merge', [
            version: 'net.minecraftforge:mergetool:1.0.4:fatjar',
            args: ["--client", "{client}", "--server", "{server}", "--ann", "{version}", "--output", "{output}"]
        ])
        RENAMETOOL = Utils.readConfig(CONFIG, 'rename', [
            version: 'net.minecraftforge.lex:vignette:0.2.0.7',
            args: ['--jar-in', '{input}', '--jar-out', '{output}', '--mapping-format', 'tsrg2', '--mappings', '{mappings}', '--fernflower-meta', '--cfg', '{libraries}']
        ])
        MERGEMAPTOOL = Utils.readConfig(CONFIG, 'mergemap', [
            version: 'net.minecraftforge:installertools:1.2.0:fatjar',
            args: ['--task', 'MERGE_MAPPING', '--left', '{mappings}', '--right', '{official}', '--right-names', 'right,left', '--classes', '--output', '{output}']
        ])
        
    }

    task downloadJson(type: Download, dependsOn: rootProject.downloadVersionManifest) {
        inputs.file rootProject.downloadVersionManifest.dest
        src { downloadVersionManifest.dest.json.versions.find{ it.id == project.name }.url }
        dest file(PATH_CACHED_VERSION + 'version.json')
        useETag 'all'
        onlyIfModified true
        quiet true
    }
    ['client', 'server', 'client_mappings', 'server_mappings'].each { id ->
        def name = 'download' + id.replace('_m', 'M').capitalize()
        task "${name}"(type: Download, dependsOn: downloadJson) {
            inputs.file downloadJson.dest
            src { downloadJson.dest.json.downloads.get(id).url }
            dest file(PATH_CACHED_VERSION + id + (id.contains('_') ? '.txt' : '.jar'))
            useETag 'all'
            onlyIfModified true
            quiet true
        }
    }
    
    task downloadLibraries(type: DownloadLibraries, dependsOn: downloadJson) {
        json = downloadJson.dest
        config = CONFIG
        dest = file(PATH_CACHED_LIBRARIES)
    } 
    task downloadFernflower(type: DownloadTool) {
        config FERNFLOWER, PATH_CACHED_LIBRARIES
    }
    task downloadMergeTool(type: DownloadTool) {
        config MERGETOOL, PATH_CACHED_LIBRARIES
    }
    task downloadRenameTool(type: DownloadTool) {
        config RENAMETOOL, PATH_CACHED_LIBRARIES
    }
    task downloadAssets(type: DownloadAssets, dependsOn: downloadJson) {
        json = downloadJson.dest
        dest = file(PATH_BUILD + '/assets/')
    }
    
    task filterClient(type: SplitJar, dependsOn: [downloadClient]) {
        mappings = file('joined.tsrg')
        source = downloadClient.dest
        slim = file(PATH_CACHED_VERSION + 'client.slim.jar')
        extra = file(PATH_CACHED_VERSION + 'client.extra.jar')
    }
    
    task filterServer(type: SplitJar, dependsOn: [downloadServer]) {
        mappings = file('joined.tsrg')
        source = downloadServer.dest
        slim = file(PATH_CACHED_VERSION + 'server.slim.jar')
        extra = file(PATH_CACHED_VERSION + 'server.extra.jar')
    }

    task mergeJars(type: MergeJar, dependsOn: [downloadMergeTool, filterClient, filterServer]) {
        config MERGETOOL, downloadMergeTool
        client filterClient.slim
        server filterServer.slim
        version project.version
        dest file(PATH_CACHED_VERSION + 'joined.jar')
    }
    
    task makeObfToIntermediate(type: RenameMappings, dependsOn: [downloadClientMappings]) {
        intermediate = file('joined.tsrg')
        if (CONFIG.official)
            official = downloadClientMappings.dest
        dest = file(PATH_CACHED_VERSION + 'obf_to_intermediate.tsrg')
    }

    def sides = [
        [name: 'client', Name: 'Client', jsonlibs: true,  extra: 'Client', assets: true,  slim: filterClient, extra: filterClient],
        [name: 'server', Name: 'Server', jsonlibs: false, extra: 'Server', assets: false, slim: filterServer, extra: filterServer],
        [name: 'joined', Name: 'Joined', jsonlibs: true,  extra: 'Client', assets: true,  slim: mergeJars,    extra: filterClient]
    ]
    
    sides.each{ info ->
        info.libraries = task "fernflowerLibraries${info.Name}"(type: CreateFernflowerLibraries, dependsOn: [downloadLibraries, downloadJson, info.slim]) {
            meta = downloadJson.dest
            config = CONFIG
            side = info.name
            root = PATH_CACHED_LIBRARIES
            if ('server'.equals(info.name))
                extras += [filterServer.extra]
            dest file(PATH_CACHED_VERSION + info.name + '.fernflower.libs.txt')
        }
        
        info.rename = task "rename${info.Name}"(type: RemapJar, dependsOn: [downloadRenameTool, info.slim, makeObfToIntermediate, info.libraries]) {
            config RENAMETOOL, downloadRenameTool
            input = 'joined'.equals(info.name) ? info.slim.dest : info.slim.slim
            mappings = makeObfToIntermediate.dest
            libraries = info.libraries.dest
            dest = file(PATH_CACHED_VERSION + info.name + '.mapped.jar')
            log = file(PATH_CACHED_VERSION + info.name + '.mapped.log')
        }
    }
    task renameJars(dependsOn: [renameClient, renameServer, renameJoined]){}

    task extractInheritance(type: ExtractInheritance, dependsOn: [downloadLibraries, mergeJars]) {
        input mergeJars.dest
        inputs.file downloadJson.dest
        dest file(PATH_CACHED_VERSION_DATA + 'inheritance.json')
        doFirst {
            downloadJson.dest.json.libraries.stream().map{ it?.downloads?.artifact?.path }.findAll{ it != null }.each{ library(file(PATH_CACHED_LIBRARIES + it)) }
        }
    }
    task extractInheritanceNamed(type: ExtractInheritance, dependsOn: [renameJoined]) {
        input renameJoined.dest
        inputs.file downloadJson.dest
        dest file(PATH_CACHED_VERSION_DATA + 'inheritance_named.json')
        doFirst {
            downloadJson.dest.json.libraries.stream().map{ it?.downloads?.artifact?.path }.findAll{ it != null }.each{ library(file(PATH_CACHED_LIBRARIES + it)) }
        }
    }

    task dumpOverrides(type: DumpOverrides, dependsOn: [extractInheritance, makeObfToIntermediate]) {
        srg makeObfToIntermediate.dest
        meta extractInheritance.dest
        dest file(PATH_CACHED_VERSION_DATA + 'overrides.txt')
    }
    
    task projectRoot(type: Copy) {
        from rootProject.file('templates/root_settings.gradle')
        into file('projects/')
        rename { 'settings.gradle' }
        expand([version: project.name])
    }

    task extractNatives(type: ExtractNatives, dependsOn: [downloadJson, downloadLibraries]) {
        meta downloadJson.dest
        cache file(PATH_CACHED_LIBRARIES)
        dest file(PATH_NATIVES)
    }
    
    task verify(type: VerifyMappings, dependsOn: [mergeJars, makeObfToIntermediate]) {
        mappings = makeObfToIntermediate.dest
        joined = mergeJars.dest
    }

    task decompileAll
    task projectAll
    task projectDeleteAll
    task projectResetAll
    task projectApplyAll
    task projectMakeAll
    
    task testDecompile
    task testCompile
    task testApi
    task testJdks(dependsOn:[testDecompile, testCompile, testApi])
    
    sides.each{ child ->        
        // Normal workflow tasks
        child.decompile = task "decompile${child.Name}"(type: FernflowerTask, dependsOn: [verify, downloadFernflower, child.rename, child.libraries]) {
            config FERNFLOWER, downloadFernflower
            javaLauncher = javaToolchains.launcherFor {
                languageVersion = JavaLanguageVersion.of(JAVA_TARGET)
            }
            libraries = child.libraries.dest
            input = child.rename.dest
            log = file(PATH_CACHED_VERSION + child.name + '.decompile.log')
            dest = file(PATH_CACHED_VERSION + child.name + '.decompile.jar')
            
        }
        decompileAll.dependsOn(child.decompile)
        
        child.pkgs = task "create${child.Name}PackageInfos"(type: MakePackageInfos, dependsOn: child.decompile) {
            input = child.decompile.dest
            template = PATH_INJECT_TEMPLATE.exists() ? PATH_INJECT_TEMPLATE : null
            dest = file(PATH_CACHED_VERSION + child.name + '.pkgs.jar')
        }
        
        def project_dir = project.file("projects/${child.name}")
        def patches_dir = project.file("patches/${child.name}")
        
        child.delete = task "project${child.Name}Delete"(type: Delete) {
            delete project_dir
        }
        projectDeleteAll.dependsOn(child.delete)

        child.project = task "project${child.Name}"(type: CreateProjectTemplate, dependsOn: [projectRoot, child.extra, child.decompile, child.pkgs] +
                (child.jsonlibs ? [downloadJson, extractNatives] : []) +
                (child.assets ? [downloadAssets] : [])
        ) {
            mustRunAfter child.delete
            dest project_dir
            distro child.name
            template rootProject.file('templates/build.gradle')
            if (child.jsonlibs)
                meta downloadJson.dest
            CONFIG?.libraries?.get(child.name)?.each { library "'${it}'" }
            libraryFile child.extra.extra
            replaceFile '{inject}', PATH_INJECT
            replaceFile '{assets}', downloadAssets.dest
            replaceFile '{natives}', extractNatives.dest
        }
        projectAll.dependsOn(child.project)

        child.resetPkgs = task "project${child.Name}ResetPackages"(type: ResetSourcesTask, dependsOn: child.pkgs) {
            mustRunAfter child.project
            root child.pkgs.dest
            target new File(project_dir, 'src/pkginfo/java')
        }
        child.reset = task "project${child.Name}Reset"(type: ResetSourcesTask, dependsOn: [child.resetPkgs, child.project, child.decompile]) {
            mustRunAfter child.project
            root child.decompile.dest
            target new File(project_dir, 'src/main/java')
        }
        projectResetAll.dependsOn(child.reset)
        
        child.apply = task "project${child.Name}ApplyPatches"(type: ApplyPatchesTask, dependsOn: child.reset) {
            target new File(project_dir, 'src/main/java')
            patches patches_dir
        }
        projectApplyAll.dependsOn(child.apply)

        child.makePatches = task "project${child.Name}MakePatches"(type: MakePatchesTask, dependsOn: child.decompile) {
            root child.decompile.dest
            target new File(project_dir, 'src/main/java')
            patches patches_dir
        }
        projectMakeAll.dependsOn child.makePatches
        
        child.renameSources = task "renameSources${child.Name}"(type: RenameSources, dependsOn: [child.apply, makeObfToIntermediate, downloadClientMappings]) {
            input = new File(project_dir, 'src/main/java')
            srg = makeObfToIntermediate.dest
            official = downloadClientMappings.dest
            dest = project.file(PATH_CACHED_VERSION + "test/official/${child.name}/src/")
        }
        
        // Tests
        def testDecompileSide = task("testDecompile${child.Name}")
        testDecompile.dependsOn(testDecompileSide)
        def testCompileSide = task("testCompile${child.Name}")
        testCompile.dependsOn(testCompileSide)
        def testApiSide = task("testApi${child.Name}")
        testApi.dependsOn(testApiSide)
        
        def jdks = [
            [name: 'hotspot8',  Name: 'HotSpot8',  version: 8,  official: false],
            [name: 'hotspot11', Name: 'HotSpot11', version: 11, official: false],
            [name: 'hotspot15', Name: 'HotSpot15', version: 15, official: false],
            [name: 'official8', Name: 'Official8', version: 8,  official: true ]
        ]
        jdks.each{ jdk ->
            def testPath = project.file(PATH_CACHED_VERSION + 'test/' + jdk.name + '/')
            
            def tstDecompile = task "testDecompile${child.Name}${jdk.Name}"(type: FernflowerTask, dependsOn: [downloadFernflower, child.rename, child.libraries]) {
                config FERNFLOWER, downloadFernflower
                javaLauncher = javaToolchains.launcherFor {
                    languageVersion = JavaLanguageVersion.of(jdk.version)
                }
                libraries = child.libraries.dest
                input = child.rename.dest
                log = new File(testPath, child.name + '.decompile.log')
                dest = new File(testPath, child.name + '.decompile.jar')
                
            }
            def tstDecompileCheck = task "testDecompile${child.Name}${jdk.Name}Compare"(type: CompareJars, dependsOn: [tstDecompile, child.decompile]) {
                expected = child.decompile.dest
                actual = tstDecompile.dest
            }
            testDecompileSide.dependsOn(tstDecompileCheck)
            
            def tstCompileClean = task "testCompile${child.Name}${jdk.Name}Clean"(type: Delete) {
                delete new File(testPath, 'classes')
            }
            
            def sourceDir = jdk.official ? child.renameSources.dest : child.renameSources.input
            
            def tstCompile = task "testCompile${child.Name}${jdk.Name}"(type: JavaCompile, dependsOn: [child.apply, tstCompileClean] + (jdk.official ? [child.renameSources] : [])) {
                javaCompiler = javaToolchains.compilerFor {
                    languageVersion = JavaLanguageVersion.of(jdk.version)
                }
                source = sourceDir
                destinationDirectory = new File(testPath, 'classes')
                options.warnings = false
                options.encoding = ENCODING
                sourceCompatibility = targetCompatibility = JAVA_TARGET <= 8 ? '1.' + JAVA_TARGET : JAVA_TARGET.toString()
                // JavaCompile task type requires classpath to be specified before the task begins execution
                // but the data isn't generated yet, so instead - inject the classpath as the first thing done when it begins
                classpath = files()
                doFirst {
                    classpath = files(java.nio.file.Files.readAllLines(child.libraries.dest.toPath()).collect { file(it.substring(3)) }) // skip "-e="
                }
            }
            testCompileSide.dependsOn(tstCompile)
            
            def tstApi = task "testApi${child.Name}${jdk.Name}"(type: CheckAPI, dependsOn: [tstCompile, rootProject.extractRuntimeApi]) {
                input = tstCompile.destinationDir
                apis.add(rootProject.extractRuntimeApi.dest)
                dest new File(testPath, 'api_errors.json')
            }
            testApiSide.dependsOn(tstApi)
        }
    }

    task generateConfiguration(type: SingleFileOutput) {
        inputs.property('config', CONFIG)
        dest file(PATH_CACHED_VERSION_DATA + 'config.json')

        doLast {
            def joinedSteps = [
                [type: 'downloadManifest'],
                [type: 'downloadJson'],
                [type: 'downloadClient'],
                [type: 'downloadServer']
            ]
            if (CONFIG.official) {
                joinedSteps += [
                    [type: 'downloadClientMappings'],
                    [type: 'mergeMappings', official: '{downloadClientMappingsOutput}']
                ]
            }
            joinedSteps += [
                [type: 'strip', name: 'stripClient', input: '{downloadClientOutput}'],
                [type: 'strip', name: 'stripServer', input: '{downloadServerOutput}'],
                [type: 'merge', client: '{stripClientOutput}', server: '{stripServerOutput}', version: project.version],
                [type: 'listLibraries'],
                [type: 'rename', input: '{mergeOutput}', libraries: '{listLibrariesOutput}', mappings: CONFIG.official ? '{mergeMappingsOutput}' : '{mappings}'],
                [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{renameOutput}'],
                [type: 'inject', input: '{decompileOutput}'],
                [type: 'patch', input: '{injectOutput}']
            ]
            
            def clientSteps = [
                [type: 'downloadManifest'],
                [type: 'downloadJson'],
                [type: 'downloadClient']
            ]
            if (CONFIG.official) {
                clientSteps += [
                    [type: 'downloadClientMappings'],
                    [type: 'mergeMappings', official: '{downloadClientMappingsOutput}']
                ]
            }
            clientSteps += [
                [type: 'strip', input: '{downloadClientOutput}'],
                [type: 'listLibraries'],
                [type: 'rename', input: '{stripOutput}', libraries: '{listLibrariesOutput}', mappings: CONFIG.official ? '{mergeMappingsOutput}' : '{mappings}'],
                [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{renameOutput}'],
                [type: 'inject', input: '{decompileOutput}'],
                [type: 'patch', input: '{injectOutput}']
            ]
            
            def serverSteps = [
                [type: 'downloadManifest'],
                [type: 'downloadJson'],
                [type: 'downloadServer']
            ]
            if (CONFIG.official) {
                serverSteps += [
                    [type: 'downloadClientMappings'],
                    [type: 'mergeMappings', official: '{downloadClientMappingsOutput}']
                ]
            }
            serverSteps += [
                [type: 'strip', input: '{downloadServerOutput}'],
                [type: 'listLibraries'],
                [type: 'rename', input: '{stripOutput}', libraries: '{listLibrariesOutput}', mappings: CONFIG.official ? '{mergeMappingsOutput}' : '{mappings}'],
                [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{renameOutput}'],
                [type: 'inject', input: '{decompileOutput}'],
                [type: 'patch', input: '{injectOutput}']
            ]
            
            def json = new groovy.json.JsonBuilder()
            json {
                spec 2
                version project.version
                official CONFIG.official
                java_target JAVA_TARGET
                encoding ENCODING
                data {
                    mappings 'config/joined.tsrg'
                    inject 'config/inject/'
                    patches {
                        client 'patches/client/'
                        joined 'patches/joined/'
                        server 'patches/server/'
                    }
                }
                steps {
                    joined joinedSteps
                    client clientSteps
                    server serverSteps
                }
                functions {
                    decompile FERNFLOWER.findAll {it.key != 'path'}
                    merge     MERGETOOL .findAll {it.key != 'path'}
                    rename    RENAMETOOL.findAll {it.key != 'path'}
                    mergeMappings MERGEMAPTOOL.findAll {it.key != 'path'}
                }
                libraries CONFIG.libraries
            }
            dest.text = groovy.json.JsonOutput.prettyPrint(json.toString())
        }
    }

    task makeZip(type: Zip, dependsOn: [generateConfiguration]) {
        archiveBaseName = rootProject.name
        archiveVersion = project.version
        destinationDirectory = file(PATH_BUILD + '/distributions')

        from generateConfiguration
        from(file('joined.tsrg')){ into 'config/' }

        def patches = file('patches')
        if (patches.exists()) {
            from(patches) {
                into 'patches/'
            }
        }

        if (PATH_INJECT != null && PATH_INJECT.exists()) {
            from(PATH_INJECT) {
                into 'config/inject/'
            }
        }
    }

    publishing {
        publications {
            if (!rootProject.hasProperty('timed_only') && (MC_VERSION.compareTo(MC_1_16_5) > 0 || !CONFIG.official)) {
                normal(MavenPublication) {
                    artifactId rootProject.name
                    artifact makeZip
                    pom {
                        name = 'MCPConfig'
                        description = 'Configuration files used for deobfuscating and modding Minecraft.'
                        url = 'https://github.com/MinecraftForge/MCPConfig'
                        scm {
                            url = 'https://github.com/MinecraftForge/MCPConfig'
                            connection = 'scm:git:git://github.com/MinecraftForge/MCPConfig.git'
                            developerConnection = 'scm:git:git@github.com:MinecraftForge/MCPConfig.git'
                        }
                        issueManagement {
                            system = 'github'
                            url = 'https://github.com/MinecraftForge/MCPConfig/issues'
                        }

                        licenses {
                            license {
                                name = 'All Rights Reserved, No redistribution.'
                                url = ''
                            }
                        }
                    }
                }
            }
            timed(MavenPublication) {
                artifactId rootProject.name
                version project.version + '-' + rootProject.TIMESTAMP
                artifact makeZip
                pom {
                    name = 'MCPConfig'
                    description = 'Configuration files used for deobfuscating and modding Minecraft.'
                    url = 'https://github.com/MinecraftForge/MCPConfig'
                    scm {
                        url = 'https://github.com/MinecraftForge/MCPConfig'
                        connection = 'scm:git:git://github.com/MinecraftForge/MCPConfig.git'
                        developerConnection = 'scm:git:git@github.com:MinecraftForge/MCPConfig.git'
                    }
                    issueManagement {
                        system = 'github'
                        url = 'https://github.com/MinecraftForge/MCPConfig/issues'
                    }

                    licenses {
                        license {
                            name = 'All Rights Reserved, No redistribution.'
                            url = ''
                        }
                    }
                }
            }
        }
        repositories {
            maven {
                if (project.hasProperty('mavenPassword')) {
                    credentials {
                        username = project.properties.mavenUser
                        password = project.properties.mavenPassword
                    }
                    url 'https://files.minecraftforge.net/maven/manage/upload'
                } else {
                    url 'file://' + rootProject.file('repo').getAbsolutePath()
                }
            }
        }
    }
}

def getVersionIndex(prop, default_) {
    if (!project.hasProperty(prop))
        return default_
    if (!VERSIONS.contains(project.getProperty(prop)))
        throw new IllegalArgumentException('Unknown version in ' + prop + ': ' + project.getProperty(prop) + ' Known: ' + VERSIONS.toString())
    return VERSIONS.indexOf(project.getProperty(prop))
}

def template = project(':' + VERSIONS[0])
def start = getVersionIndex('startVersion', 0)
def end = getVersionIndex('endVersion', VERSIONS.size - 1)

if (start > end)
    throw new IllegalArgumentException('Invalid start and end range: ' + VERSIONS[start] + ' > ' + VERSIONS[end])

template.tasks.each{t ->
    def myTask = project.tasks.findByName(t.name) ?: project.tasks.create(t.name)
    for (int x = start; x <= end; x++) {
        def task = project(VERSIONS[x]).tasks.findByName(t.name)
        if (task != null)
            myTask.dependsOn task
    }
}

