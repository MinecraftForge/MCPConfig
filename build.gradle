buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        jcenter()
        maven { url = 'http://files.minecraftforge.net/maven/'}
        maven { url = 'https://plugins.gradle.org/m2/' }
    }
    dependencies {
        classpath 'org.ow2.asm:asm:6.1.1'
        classpath 'org.ow2.asm:asm-tree:6.1.1'
        classpath 'net.minecraftforge:mapping-verifier:1.0.6+'
        classpath 'de.undercouch:gradle-download-task:3.4.3'
        classpath 'de.siegmar:fastcsv:1.0.3'
    }
}

import de.undercouch.gradle.tasks.download.Download
import groovy.io.FileType
import groovy.json.JsonSlurper
import groovy.json.JsonBuilder
import java.util.regex.Matcher
import java.util.regex.Pattern
import java.util.zip.ZipFile
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream
import java.security.MessageDigest
import org.objectweb.asm.Type
import net.minecraftforge.lex.ExtractInheritance
import net.minecraftforge.mappingverifier.MappingVerifier
import net.minecraftforge.mcpconfig.tasks.*
import uk.jamierocks.propatcher.task.*
import de.siegmar.fastcsv.reader.CsvContainer
import de.siegmar.fastcsv.reader.CsvReader
import de.siegmar.fastcsv.reader.CsvRow
import java.util.stream.Collectors

plugins {
    id 'de.undercouch.download' version '3.3.0'
    id 'uk.jamierocks.propatcher' version '1.3.1' apply false
}
apply plugin: 'maven'

archivesBaseName = 'mcp_config'
group = 'de.oceanlabs.mcp'
    
ext {
    META_CACHE_FILE = 'meta_cache.json'
    META_CACHE = !file(META_CACHE_FILE).exists() ? [:] : new JsonSlurper().parseText(file(META_CACHE_FILE).text)
    VERSIONS = subprojects.collect{it.name}.sort{a,b -> compareVersion(a, b)} as List
    NULL_OUPUT = new OutputStream() { public void write(int b){} }
    TIMESTAMP = (new Date()).format('yyyyMMdd.HHmmss')
}
String.metaClass.rsplit = { chr -> [delegate.substring(0, delegate.lastIndexOf(chr)), delegate.substring(delegate.lastIndexOf(chr)+1)] }

task downloadVersionManifest(type: Download) {
    src 'https://launchermeta.mojang.com/mc/game/version_manifest.json'
    dest file('build/versions/version_manifest.json')
    overwrite true
    doLast {
        def json = new JsonSlurper().parseText(downloadVersionManifest.dest.text)
        
        //Update the cache of all versions we can.
        rootProject.subprojects.each { sub ->
            def entry = json.versions.find{it.id == sub.name}
            if (entry != null) 
                META_CACHE.get(sub.name, [:])['json'] = entry.url
        }
        META_CACHE = META_CACHE.sort{a,b -> compareVersion(a.key, b.key)} //I like it pretty so lets sort it.
        file(META_CACHE_FILE).write(new JsonBuilder(META_CACHE).toPrettyString())
        
        downloadVersionManifest.dest.write(new JsonBuilder(json).toPrettyString()) //Pretty it up
    }
}

def compareVersion(a, b) {
    def aIsWeek = a.length() == 6 && a.charAt(2) == 'w'
    def bIsWeek = b.length() == 6 && b.charAt(2) == 'w'
    if (aIsWeek == bIsWeek) {
        if (aIsWeek) {
            def (aYear, aWeek, aRev) = splitWeekly(a)
            def (bYear, bWeek, bRev) = splitWeekly(b)
            return aYear != bYear ? aYear - bYear : aWeek != bWeek ? aWeek - bWeek : aRev.compareTo(bRev)
        }
        return compareFull(a, b)        
    } else if (aIsWeek) {
        def (aYear, aWeek, aRev) = splitWeekly(a)
        def bFull = splitFull(b)[0].join('.')
        return compareFull(findFull(aYear, aWeek) + '-pre0', bFull)
    } else {
        def aFull = splitFull(a)[0].join('.')
        def (bYear, bWeek, bRev) = splitWeekly(b)
        return compareFull(aFull, findFull(bYear, bWeek) + '-pre0')
    }
}
def compareFull(a, b) {
    def (aFull, aPre) = splitFull(a)
    def (bFull, bPre) = splitFull(b)
    for (int x = 0; x < aFull.length; x++) {
        if (x >= bFull.length)
            return 1 //1.2.1 vs 1.2
        if (aFull[x] != bFull[x])
            return aFull[x] - bFull[x]
    }
    if (aFull.length < bFull.length)
        return -1 //1.2 vs 1.2.1
    return aPre - bPre  
}
def findFull(year, week) {
    def value = (year * 100) + week
    if (value >= 1743 && value <= 1822)
        return '1.13'
    if (value >= 1830 && value <= 1833)
        return '1.13.1'
    if (value >= 1934)
        return '1.15'
    throw new RuntimeException('Unknown week range: ' + value)
}
def splitWeekly(ver) {
    return [ver.substring(0, 2) as int, ver.substring(3, 5) as int, ver.substring(5)]
}
def splitFull(ver) {
    def pre = Integer.MAX_VALUE
    if (ver.indexOf('-') != -1) {
        pre = ver.split('-')[1].substring(3) as int
        ver = ver.split('-')[0]
    }
    return [ver.split('\\.').collect{it as int} as int[], pre]
}
File.metaClass.getSha1 = { !delegate.exists() ? null : MessageDigest.getInstance('SHA-1').digest(delegate.bytes).encodeHex().toString() }

subprojects {
    apply plugin: 'de.undercouch.download'
    apply plugin: 'maven'
    apply plugin: 'maven-publish'
    archivesBaseName = rootProject.archivesBaseName
    group = rootProject.group
    version = name

    ext {
        FORGE_MAVEN = 'http://files.minecraftforge.net/maven/'
        PATH_BUILD = rootProject.file('build').absolutePath
        PATH_VERSION = rootProject.file('versions').absolutePath + '/' + project.version + '/'
        PATH_DISTRO = PATH_BUILD + '/distributions'
        PATH_CACHED_LIBRARIES = PATH_BUILD + '/libraries/'
        PATH_CACHED_VERSIONS = PATH_BUILD + '/versions/'
        PATH_CACHED_VERSION = PATH_CACHED_VERSIONS + project.version + '/'
        PATH_CACHED_VERSION_DATA = PATH_CACHED_VERSION + 'data/'
        PATH_EXCEPTIONS =  file('exceptions.txt').exists() ? 'exceptions.txt' : rootProject.file('config/exceptions.txt').absolutePath
        PATH_ASTYLE = file('astyle.cfg').exists() ? 'astyle.cfg' : rootProject.file('config/astyle.cfg').absolutePath
        PATH_INJECT = file('inject').exists() ? file('inject') : null
        PATH_INJECT_TEMPLATE = PATH_INJECT == null || !new File(PATH_INJECT, 'package-info-template.java').exists() ? null : new File(PATH_INJECT, 'package-info-template.java')
        PROJECT_TEMPLATE = file('project_template.gradle').exists() ? file('project_template.gradle') : rootProject.file('project_template.gradle')
        PATH_TSRG = PATH_BUILD + '/versions/' + project.version + '/mappings.tsrg'
        PATH_ASSETS = PATH_BUILD + '/assets'
        PATH_NATIVES = PATH_VERSION + 'natives'
        
        MCPNAMES = null
        if (rootProject.hasProperty('mapping_version')) {
            MCPNAMES = [
                version: rootProject.properties.mapping_version,
                path: mavenPath(rootProject.properties.mapping_version),
                repo: rootProject.hasProperty('mapping_repo') ? rootProject.properties.mapping_repo : FORGE_MAVEN
            ]
        }
        
        CONFIG = file('config.json').exists() ? new JsonSlurper().parse(file('config.json')) : [:]
        MCINJECTOR = [
            version: CONFIG.get('mcinjector', [:]).version,
            args: CONFIG.mcinjector.get('args', []),
            path: mavenPath(CONFIG.mcinjector.version),
            repo: CONFIG.mcinjector.get('repo', FORGE_MAVEN)
        ]
        FERNFLOWER = [
            version: CONFIG.get('fernflower', [:]).version,
            args: CONFIG.fernflower.get('args', []),
            jvmargs: CONFIG.fernflower.get('jvmargs', []),
            path: mavenPath(CONFIG.fernflower.version),
            repo: CONFIG.fernflower.get('repo', FORGE_MAVEN)
        ]
        def mergeDefault = [
            version: 'net.minecraftforge:mergetool:1.0.4:fatjar',
            args: ["--client", "{client}", "--server", "{server}", "--ann", "{version}", "--output", "{output}"]
        ]
        MERGETOOL = [
            version: CONFIG.get('merge', mergeDefault).version,
            args: CONFIG.merge.get('args', []),
            jvmargs: CONFIG.merge.get('jvmargs', []),
            path: mavenPath(CONFIG.merge.version),
            repo: CONFIG.merge.get('repo', FORGE_MAVEN)
        ]
        def renameDefault = [
            version: 'net.md-5:SpecialSource:1.8.3:shaded',
            args: ['--in-jar', '{input}', '--out-jar', '{output}', '--srg-in', '{mappings}'],
            repo: 'http://repo1.maven.org/maven2/'
        ]
        RENAMETOOL = [
            version: CONFIG.get('rename', renameDefault).version,
            args: CONFIG.rename.get('args', []),
            jvmargs: CONFIG.rename.get('jvmargs', []),
            path: mavenPath(CONFIG.rename.version),
            repo: CONFIG.rename.get('repo', FORGE_MAVEN)
        ]
    }
    
    tasks.whenTaskAdded {task ->
        def name = task.name.toLowerCase()
        if (MCINJECTOR.version == null && name.contains('mcinject')) {
            task.enabled = false
        }
        if ((MCINJECTOR.version == null || FERNFLOWER.version == null) && (name.contains('fernflower') || name.contains('project'))) {
            task.enabled = false
        }
    }

    task downloadJson(type: Download, dependsOn: rootProject.downloadVersionManifest) {
        inputs.file rootProject.downloadVersionManifest.dest
        doFirst {
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            def entry = json.versions.find{it.id == project.version}
            def url = entry != null ? entry.url : rootProject.META_CACHE.get(project.version, ['json':null]).json
            if (url == null)
                url = 'https://s3.amazonaws.com/Minecraft.Download/versions/' + project.version + '/' + project.version + '.json'
            downloadJson.src url
        }
        dest file(PATH_CACHED_VERSION + project.version + '.json')
        overwrite false
        doLast {
            def json = new JsonSlurper().parseText(downloadJson.dest.text)
            downloadJson.dest.write(new JsonBuilder(json).toPrettyString()) //Pretty it up
        }
    }
    task downloadClient(type: Download, dependsOn: downloadJson) {
        inputs.file downloadJson.dest
        doFirst {
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            downloadClient.src json.downloads.client.url
        }
        dest file(PATH_CACHED_VERSION + project.version + '.client.jar')
        overwrite false
    }
    task downloadClientMappings(type: Download, dependsOn: downloadJson) {
        inputs.file downloadJson.dest
        doFirst {
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            downloadClientMappings.src json.downloads.client_mappings?.url
        }
        dest file(PATH_CACHED_VERSION + project.version + '.client.txt')
        overwrite false
    }
    task downloadServer(type: Download, dependsOn: downloadJson) {
        inputs.file downloadJson.dest
        doFirst {
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            downloadServer.src json.downloads.server.url
        }
        dest file(PATH_CACHED_VERSION + project.version + '.server.jar')
        overwrite false
    }
    task downloadServerMappings(type: Download, dependsOn: downloadJson) {
        inputs.file downloadJson.dest
        doFirst {
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            downloadServerMappings.src json.downloads.server_mappings?.url
        }
        dest file(PATH_CACHED_VERSION + project.version + '.server.txt')
        overwrite false
    }
    task downloadLibraries(dependsOn: downloadJson) {
        inputs.file downloadJson.dest
        doLast {
            def json = new JsonSlurper().parseText(downloadJson.dest.text)
            json.libraries.each {lib ->
                def artifacts = [lib.downloads.artifact] + lib.downloads.get('classifiers', [:]).values()
                artifacts.each{ art -> 
                    def target = file(PATH_CACHED_LIBRARIES + art.path)
                    if (!target.exists()) {
                        download {
                            src art.url
                            dest target
                        }
                    }
                }
            }
            for (def side : ['client', 'server', 'joined']) {
                if (CONFIG?.libraries?.get(side) != null) {
                    CONFIG.libraries.get(side).each { art -> 
                        def path = mavenPath(art)
                        def target = file(PATH_CACHED_LIBRARIES + path)
                        if (!target.exists()) {
                            download {
                                src FORGE_MAVEN + path //TODO: Config this somehow?
                                dest = target
                            }
                        }
                    }
                }
            }
        }
    }
    task downloadMCInjector(type: Download) {
        inputs.property('url', MCINJECTOR.repo + MCINJECTOR.path)
        src MCINJECTOR.repo + MCINJECTOR.path
        dest file(PATH_CACHED_LIBRARIES + MCINJECTOR.path)
        overwrite false
    }
    task downloadFernflower(type: Download) {
        inputs.property('url', FERNFLOWER.repo + FERNFLOWER.path)
        src FERNFLOWER.repo + FERNFLOWER.path
        dest file(PATH_CACHED_LIBRARIES + FERNFLOWER.path)
        overwrite false
    }
    task downloadMergeTool(type: Download) {
        inputs.property('url', MERGETOOL.repo + MERGETOOL.path)
        src MERGETOOL.repo + MERGETOOL.path
        dest file(PATH_CACHED_LIBRARIES + MERGETOOL.path)
        overwrite false
    }
    task downloadRenameTool(type: Download) {
        inputs.property('url', RENAMETOOL.repo + RENAMETOOL.path)
        src RENAMETOOL.repo + RENAMETOOL.path
        dest file(PATH_CACHED_LIBRARIES + RENAMETOOL.path)
        overwrite false
    }
    task downloadAssets(dependsOn: downloadJson) {
        inputs.file downloadJson.dest
        doFirst {
            def dl = new JsonSlurper().parse(downloadJson.dest).assetIndex
            def index = file(PATH_ASSETS + '/indexes/' + dl.id + '.json')
            if (index.sha1 != dl.sha1) {
                download {
                    src dl.url
                    dest index
                }
            }
            new JsonSlurper().parse(index).objects.each { asset ->
                def key = asset.value.hash.take(2) + '/' + asset.value.hash
                def target = file(PATH_ASSETS + '/objects/' + key)
                if (!target.exists()) {
                    download {
                        src 'http://resources.download.minecraft.net/' + key
                        dest target
                    }
                }
            }
        }
    }
    if (MCPNAMES != null) {
        task downloadMCPNames(type: Download) {
            inputs.property('version', MCPNAMES.version)
            src MCPNAMES.repo + MCPNAMES.path
            dest file(PATH_CACHED_LIBRARIES + MCPNAMES.path)
            overwrite false
        }
    }
    
    task convertMappings(type: ConvertMappings, dependsOn: [downloadClientMappings]) {
        doFirst {
            proguard file(downloadClientMappings.dest)
            tsrg file(PATH_TSRG) // server mappings are subset of client mappings, so no joining needed
            overwrite false
        }
    }
    
    task filterClient(type: Zip, dependsOn: [downloadClient, convertMappings]) {
        archiveName = project.version + '.client.slim.jar'
        destinationDir = file(PATH_CACHED_VERSION)
        from zipTree(downloadClient.dest)
        doLast {
            loadSRG(file(PATH_TSRG))['CL:'].keySet().each{ include it + '.class' }
        }
    }
    task filterClientExtra(type: Zip, dependsOn: [downloadClient, convertMappings]) {
        archiveName = project.version + '.client.extra.jar'
        destinationDir = file(PATH_CACHED_VERSION)
        from zipTree(downloadClient.dest)
        doLast {
            loadSRG(file(PATH_TSRG))['CL:'].keySet().each{ exclude it + '.class' }
        }
    }
    task filterServer(type: Zip, dependsOn: [downloadServer, convertMappings]) {
        archiveName = project.version + '.server.slim.jar'
        destinationDir = file(PATH_CACHED_VERSION)
        from zipTree(downloadServer.dest)
        doLast {
            loadSRG(file(PATH_TSRG))['CL:'].keySet().each{ include it + '.class' }
        }
    }
    task filterServerExtra(type: Zip, dependsOn: [downloadServer, convertMappings]) {
        archiveName = project.version + '.server.extra.jar'
        destinationDir = file(PATH_CACHED_VERSION)
        from zipTree(downloadServer.dest)
        doLast {
            loadSRG(file(PATH_TSRG))['CL:'].keySet().each{ exclude it + '.class' }
        }
    }
    task filterJars(dependsOn: [filterClient, filterClientExtra, filterServer, filterServerExtra]){}
    
    task mergeJars(type: MergeJar, dependsOn: [downloadMergeTool, filterClient, filterServer]) {
        jar downloadMergeTool.dest
        jvmArgs MERGETOOL.jvmargs
        client filterClient.archivePath
        server filterServer.archivePath
        version project.version
        dest file(PATH_CACHED_VERSION + project.version + '.joined.jar')
        args MERGETOOL.args
    }

    task renameClient(type: RemapJar, dependsOn: [downloadRenameTool, downloadLibraries, filterClient]) {
        jar downloadRenameTool.dest
        jvmArgs RENAMETOOL.jvmargs
        input filterClient.archivePath
        mappings file(PATH_VERSION + 'joined.tsrg')
        args RENAMETOOL.args
        dest file(PATH_CACHED_VERSION + project.version + '.client.mapped.jar')
    }
    task renameServer(type: RemapJar, dependsOn: [downloadRenameTool, downloadLibraries, filterServer]) {
        jar downloadRenameTool.dest
        jvmArgs RENAMETOOL.jvmargs
        input filterServer.archivePath
        mappings file(PATH_VERSION + 'joined.tsrg')
        args RENAMETOOL.args
        dest file(PATH_CACHED_VERSION + project.version + '.server.mapped.jar')
    }
    task renameJoined(type: RemapJar, dependsOn: [downloadRenameTool, downloadLibraries, mergeJars]) {
        jar downloadRenameTool.dest
        jvmArgs RENAMETOOL.jvmargs
        input mergeJars.dest
        mappings file(PATH_VERSION + 'joined.tsrg')
        args RENAMETOOL.args
        dest file(PATH_CACHED_VERSION + project.version + '.joined.mapped.jar')
    }
    task renameJars(dependsOn: [renameClient, renameServer, renameJoined]){}
    
    task extractInheritance(type: ExtractInheritance, dependsOn: [downloadLibraries, mergeJars]) {
        input mergeJars.dest
        inputs.file downloadJson.dest
        dest file(PATH_CACHED_VERSION_DATA + 'inheritance.json')
        doFirst {
            def json = new JsonSlurper().parseText(downloadJson.dest.text)
            json.libraries.each{ addLibrary(file(PATH_CACHED_LIBRARIES + it.downloads.artifact.path)) }
        }
    }
    task extractInheritanceNamed(type: ExtractInheritance, dependsOn: [renameJoined]) {
        input renameJoined.dest
        inputs.file downloadJson.dest
        dest file(PATH_CACHED_VERSION_DATA + 'inheritance_named.json')
        doFirst {
            def json = new JsonSlurper().parseText(downloadJson.dest.text)
            json.libraries.each{ addLibrary(file(PATH_CACHED_LIBRARIES + it.downloads.artifact.path)) }
        }
    }

    task makeSRG(type: SingleFileOutput) {
        inputs.file(PATH_VERSION + 'joined.tsrg')
        dest file(PATH_CACHED_VERSION_DATA + 'joined.srg')
        doLast {
            def SRG = loadSRG(inputs.files.singleFile)

            dest.withWriter('UTF-8') { writer ->
                def format_class = { it.indexOf('/') != -1 ? it : it.split('\\$').collect{it.padLeft(1000, ' ')}.join('$') }
                def format_field = { format_class.call(it.rsplit('/')[0]) + '/' + it.rsplit('/')[1].padLeft(1000, ' ') }
                def format_method = { format_field.call(it.split(' ')[0]) + ' ' + it.split(' ')[1] }

                SRG['CL:'].sort{format_class.call(it.key)}.each{k,v -> writer.write('CL: ' + k + ' ' + v + '\n')}
                SRG['FD:'].sort{format_field.call(it.key)}.each{k,v -> writer.write('FD: ' + k + ' ' + v + '\n')}
                SRG['MD:'].sort{format_method.call(it.key)}.each{k,v -> writer.write('MD: ' + k + ' ' + v + '\n')}
            }
        }
    }
    task makeCSRG(type: SingleFileOutput) {
        inputs.file(PATH_VERSION + 'joined.tsrg')
        dest file(PATH_CACHED_VERSION_DATA + 'joined.csrg')
        doLast {
            def current = null
            dest.withWriter('UTF-8') { writer ->
                inputs.files.singleFile.collect{splitComment(it)[0]}.findAll{it != null}.each { line ->
                    if (!line.startsWith('\t')) {
                        current = line.split(' ')[0]
                        writer.write(line + '\n')
                    } else {
                        if (current == null)
                            throw new Exception("TSRG format screwed up... Null class context!")
                        writer.write(current + ' ' + line.trim() + '\n')
                    }
                }
            }
        }
    }

    task fixAccessLevels(type: SingleFileOutput, dependsOn: ['extractInheritance', 'makeSRG']) {
        inputs.file extractInheritance.dest
        dest file(PATH_CACHED_VERSION_DATA + 'access.txt')
        doLast {
            def srg = loadSRG(makeSRG.dest)
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            outputs.files.singleFile.withWriter('UTF-8') { writer ->
                json.each{ k,v ->
                    json[k]['methods']?.each{ sig,data ->
                        if (data['override']) {
                            def access = json[data['override']] ? json[data['override']]['methods'] ? json[data['override']]['methods'][sig] ? json[data['override']]['methods'][sig]['access'] : null : null : null
                            if (access != null) {
                                if ((data['access'] & 0b1010) == 0) { // STATIC PRIVATE
                                    def old = data['access'] & 0b0010 ? 0 : data['access'] & 0b0100 ? 2 : data['access'] & 0b0001 ? 3 : 1
                                    def top =       access   & 0b0010 ? 0 :       access   & 0b0100 ? 2 :       access   & 0b0001 ? 3 : 1
                                    def names = ['PRIVATE', 'DEFAULT', 'PROTECTED', 'PUBLIC']
                                    if (old < top) {
                                        def mapped = srg['MD:'][k + '/' + sig]
                                        if (mapped == null) {
                                            print('Missing srg mapping for access: ' + k + '/' + sig + '\n')
                                        }
                                        else {
                                            def mtd = mapped.split(' ')
                                            def ind = mtd[0].lastIndexOf('/')
                                            mtd = mtd[0].substring(0, ind) + ' ' + mtd[0].substring(ind+1) + ' ' + mtd[1]
                                            //println(mtd + " " + names[old] + " " + names[top])
                                            writer.write(names[top] + ' ' + mtd + '\n')
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    task dumpOverrides(type: SingleFileOutput, dependsOn: ['extractInheritance', 'makeSRG']) {
        inputs.file extractInheritance.dest
        dest file(PATH_CACHED_VERSION_DATA + 'overrides.txt')
        doLast {
            def srg = loadSRG(makeSRG.dest)
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            def methods = [] as HashSet

            json.each{ k,v ->
                json[k]['methods']?.each{ sig,data ->
                    if (data['override']) {
                        def mtd = srg['MD:'][k + '/' + sig]
                        methods.add(mtd)
                    }
                }
            }

            dest.withWriter('UTF-8') { writer ->
                methods = methods.sort{it}
                methods.each{ writer.write(it + '\n') }
            }
        }
    }

    task dumpStatic(type: SingleFileOutput, dependsOn: ['extractInheritance', 'makeSRG']) {
        inputs.file extractInheritance.dest
        dest file(PATH_CACHED_VERSION_DATA + 'static_methods.txt')
        doLast {
            def srg = loadSRG(makeSRG.dest)
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            def methods = [] as HashSet

            json.each{ cls,data ->
                data['methods']?.findAll{k,v -> (v['access'] & 0b1000) != 0}.each{ sig,__ ->
                    def mtd = srg['MD:'][cls + '/' + sig]
                    if (mtd && !mtd.contains('()') && mtd.contains('func_')) {
                        mtd = mtd.split(' ')[0]
                        methods.add(mtd.substring(mtd.lastIndexOf('/') + 1))
                    }
                }
            }

            dest.withWriter('UTF-8') { writer ->
                methods = methods.sort{it}
                methods.each{ writer.write(it + '\n') }
            }
        }
    }

    task makeExceptions(type: SingleFileOutput, dependsOn: [extractInheritance, makeSRG]) {
        inputs.file PATH_EXCEPTIONS
        dest file(PATH_CACHED_VERSION_DATA + 'exceptions.txt')
        doLast {
            def srg = loadSRG(makeSRG.dest)
            def json = new JsonSlurper().parseText(extractInheritance.dest.text)
            def known = [:]
            srg['MD:'].each{k,v -> known[v] = k}
            def methods = [:]

            def current_class = null
            def line_num = 0

            inputs.files.singleFile.eachLine { line ->
                line_num++
                if (line.indexOf('#') != -1)
                    line = line.substring(0, line.indexOf('#'))
                if (line.trim().isEmpty())
                    return

                def pts = line.trim().split(' ')
                if (line.startsWith('\t')) {
                    if (current_class == null)
                        throw new Exception('Invalid exceptions.txt format on line #' + line_num + ': ' + line)
                    def key = current_class + '/' + pts[0] + ' ' + pts[1]
                    if (!methods[key])
                        methods[key] = [] as HashSet
                    for (int x = 2; x < pts.length; x++)
                        methods[key].add(pts[x])
                } else if (pts.length == 1) {
                    current_class = pts[0]
                } else if (pts.length >= 3) {
                    current_class = null
                    def key = pts[0] + '/' + pts[1] + ' ' + pts[2]
                    if (!methods[key])
                        methods[key] = [] as HashSet
                    for (int x = 3; x < pts.length; x++)
                        methods[key].add(pts[x])
                } else
                    throw new Exception('Invalid exceptions.txt format on line #' + line_num + ': ' + line)
            }

            json.each{ k,v ->
                json[k]['methods']?.each{ sig,data ->
                    if (data['override']) {
                        def mtd = srg['MD:'][k + '/' + sig]
                        def ord = data['override'] + '/' + sig

                        if (srg['MD:'][ord])
                            ord = srg['MD:'][ord]

                        if (methods[ord]) {
                            if (!methods[mtd])
                                methods[mtd] = [] as HashSet
                            methods[ord].each{ methods[mtd].add(it) }

                            if (data['bouncer']) {
                                def bnc = srg['MD:'][k +'/' + data['bouncer']['name'] + ' ' + data['bouncer']['desc']]
                                if (!methods[bnc])
                                    methods[bnc] = [] as HashSet
                                methods[ord].each{ methods[bnc].add(it) }
                            }
                        }
                    }
                }
            }

            outputs.files.singleFile.withWriter('UTF-8') { writer ->
                methods.keySet().sort{it}.findAll{known.containsKey(it)}.each{ writer.write(it + ' ' + methods[it].join(' ') + '\n') }
            }
        }
    }
      
    task fernflowerLibrariesClient(type: SingleFileOutput, dependsOn: [downloadLibraries]) {
        inputs.file downloadJson.dest
        dest file(PATH_CACHED_VERSION + project.version + '.client.fernflower.libs.txt')
        doLast {
            def json = new JsonSlurper().parseText(downloadJson.dest.text)
            dest.withWriter('UTF-8'){ writer ->
                def libs = json.libraries.collect{lib -> lib.downloads.artifact.path}
                if (CONFIG?.libraries?.client != null) {
                    CONFIG.libraries.client.collect{ mavenPath(it) }.each { libs.add(it) }
                }
                
                libs.unique{a,b -> a <=> b}.each { lib -> writer.write('-e=' + file(PATH_CACHED_LIBRARIES + lib).absolutePath + '\n') }
            }
        }
    }
    task fernflowerLibrariesJoined(type: SingleFileOutput, dependsOn: [downloadLibraries]) {
        inputs.file downloadJson.dest
        dest file(PATH_CACHED_VERSION + project.version + '.joined.fernflower.libs.txt')
        doLast {
            def json = new JsonSlurper().parseText(downloadJson.dest.text)
            dest.withWriter('UTF-8'){ writer ->
                def libs = json.libraries.collect{lib -> lib.downloads.artifact.path}
                if (CONFIG?.libraries?.joined != null) {
                    CONFIG.libraries.joined.collect{ mavenPath(it) }.each { libs.add(it) }
                }
                
                libs.unique{a,b -> a <=> b}.each { lib -> writer.write('-e=' + file(PATH_CACHED_LIBRARIES + lib).absolutePath + '\n') }
            }
        }
    }
    task fernflowerLibrariesServer(type: SingleFileOutput, dependsOn: [filterServerExtra, downloadLibraries]) {
        inputs.file filterServerExtra.archivePath
        dest file(PATH_CACHED_VERSION + project.version + '.server.fernflower.libs.txt')
        doLast {
            dest.withWriter('UTF-8'){ writer -> 
                if (CONFIG?.libraries?.server != null) {
                    CONFIG.libraries.server.collect{ mavenPath(it) }.each { lib -> writer.write('-e=' + file(PATH_CACHED_LIBRARIES + lib).absolutePath + '\n') }
                }
                writer.write('-e=' + filterServerExtra.archivePath.absolutePath + '\n')
            }
        }
    }
    
    def sides = [
        [name: 'Client', jsonlibs: true, extra: 'Client', assets: true],
        [name: 'Server', jsonlibs: false, extra: 'Server', assets: false],
        [name: 'Joined', jsonlibs: true, extra: 'Client', assets: true]
    ]
    
    task mcinjectAll
    task fernflowerAll
    task fernflowerInject
    task projectAll
    task projectDelete
    task projectReset
    task projectApplyPatches
    task projectMakePatches
    
    task projectRoot(type: SingleFileOutput) {
        dest file('projects/settings.gradle')
        doLast {
            dest.text = 
            "def sides = [" + sides.collect{"'${it.name.toLowerCase()}'"}.join(', ') + "]\n" +
            "file('.').eachDir{ dir ->\n" + 
            "  if (sides.contains(dir.name)) {\n" + 
            "    include dir.name\n" +
            "    project(':' + dir.name).name = '${project.name}-' + dir.name\n" +
            "  }\n" +
            "}"
        }
        
    }
    
    task extractNatives(dependsOn: [downloadJson, downloadLibraries]) {
        inputs.file downloadJson.dest
        doLast {            
            def json = new JsonSlurper().parse(downloadJson.dest)
            json.libraries.findAll{ testJsonRules(it.rules) }.collect{ it.downloads.get('classifiers', null) }.findAll{ it != null }.each { cls -> 
                cls.entrySet().findAll{it.key.startsWith('natives-')}.collect{ it.value }.each { art ->
                    //logger.lifecycle('Native: ' + art.path)
                    def lib = file(PATH_CACHED_LIBRARIES + art.path)
                    if (lib.exists()) {
                        new ZipFile(lib).withCloseable{ zip ->
                            zip.entries().findAll{ !it.isDirectory() && !it.name.startsWith('META-INF/')  && !it.name.endsWith('.sha1') && !it.name.endsWith('.git') }.each { entry ->
                                def target = new File(PATH_NATIVES, entry.name)
                                //logger.lifecycle('  ' + entry.name)
                                if (!target.exists()) {
                                    target.parentFile.mkdirs()
                                    target.bytes = zip.getInputStream(entry).bytes
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    for (def child_outer : sides) {
        def child = child_outer
        def dir = file("projects/${child.name.toLowerCase()}")
        def dir_patches = file("patches/${child.name.toLowerCase()}")
        
        if (MCINJECTOR.version != null) {
            task "mcinject${child.name}"(type: MCInjectTask, dependsOn: [downloadMCInjector, "rename${child.name}", makeExceptions, fixAccessLevels]) {
                jar downloadMCInjector.dest
                access fixAccessLevels.dest
                constructors file(PATH_VERSION + 'constructors.txt')
                exceptions makeExceptions.dest
                standardOutput rootProject.NULL_OUPUT
                log file(PATH_CACHED_VERSION + project.version + '.' + child.name.toLowerCase() + '.mci.log')
                args MCINJECTOR.args
                input tasks.getByName("rename${child.name}").dest
                dest file(PATH_CACHED_VERSION + project.version + '.' + child.name.toLowerCase() + '.mci.jar')
            }
            mcinjectAll.dependsOn "mcinject${child.name}"
            
            if (FERNFLOWER.version != null) {
                task "fernflower${child.name}"(type: FernflowerTask, dependsOn: [downloadFernflower, "mcinject${child.name}", "fernflowerLibraries${child.name}"]) {
                    jar downloadFernflower.dest
                    jvmArgs FERNFLOWER.jvmargs
                    libraries tasks.getByName("fernflowerLibraries${child.name}").dest
                    log file(PATH_CACHED_VERSION + project.version + '.' + child.name.toLowerCase() + '.decomp.log')
                    args FERNFLOWER.args
                    input tasks.getByName("mcinject${child.name}").dest
                    dest file(PATH_CACHED_VERSION + project.version + '.' + child.name.toLowerCase() + '.decomp.jar')
                }
                fernflowerAll.dependsOn "fernflower${child.name}"
        
                task "fernflower${child.name}Inject"(dependsOn: ["fernflower${child.name}"]) {
                    if (PATH_INJECT_TEMPLATE != null) {
                        inputs.file PATH_INJECT_TEMPLATE
                        inputs.file tasks.getByName("fernflower${child.name}").dest
                        doFirst {
                            def template = PATH_INJECT_TEMPLATE.text
                            def visited = ['net', 'net/minecraft'].toSet()
                            def target = new File(dir, 'src/pkginfo/java')
                            new ZipFile(tasks.getByName("fernflower${child.name}").dest).withCloseable{ zip ->
                                zip.entries().each { entry ->
                                    def folder = entry.isDirectory() && !entry.name.endsWith("/") ? entry.name : entry.name.indexOf('/') == -1 ? '' : entry.name.substring(0, entry.name.lastIndexOf('/'))
                                    if (visited.add(folder)) {
                                        def parent = new File(target, folder)
                                        if (!parent.exists())
                                            parent.mkdirs()
                                        new File(parent, 'package-info.java').text = template.replace('{PACKAGE}', folder.replaceAll('/', '.'))
                                    }
                                }
                            }
                        }
                    }
                }
                fernflowerInject.dependsOn "fernflower${child.name}Inject"
                
                if (MCPNAMES != null) {
                    task "mcpmap${child.name}"(dependsOn: [downloadMCPNames, "fernflower${child.name}"]) {
                        def out_path = PATH_CACHED_VERSION + project.version + '.' + child.name.toLowerCase() + '.mcpmaped.jar'
                        inputs.file downloadMCPNames.dest 
                        inputs.file tasks.getByName("fernflower${child.name}").dest
                        outputs.file out_path
                        doFirst {
                            def names = [:]
                            new ZipFile(downloadMCPNames.dest).withCloseable{ zip -> 
                                zip.entries().findAll{ !it.directory && it.name.endsWith('.csv') }
                                .each {
                                    def reader = new CsvReader()
                                    reader.containsHeader = true
                                    def csv = reader.read(new InputStreamReader(zip.getInputStream(it)))
                                    csv.rows.each { names[it.getField('searge') == null ? it.getField('param') : it.getField('searge')] = it.getField('name') }
                                }
                            }
                            new ZipFile(tasks.getByName("fernflower${child.name}").dest).withCloseable { izip -> 
                                new ZipOutputStream(new FileOutputStream(out_path)).withCloseable { ozip -> 
                                    izip.entries().each { entry ->
                                        def oentry = new ZipEntry(entry.name)
                                        oentry.time = 0
                                        ozip.putNextEntry(oentry)
                                        if (entry.name.endsWith('.java'))
                                            ozip << izip.getInputStream(entry).text.replaceAll(/func_[0-9]+_[a-zA-Z_]+|field_[0-9]+_[a-zA-Z_]+|p_[\w]+_\d+_\b/) { name -> names.getOrDefault(name, name) } 
                                        else 
                                            ozip << izip.getInputStream(entry)
                                        ozip.closeEntry()
                                    }
                                }
                            }
                        }
                    }
                }
                
                task "project${child.name}"(dependsOn: [projectRoot, "filter${child.extra}Extra", "fernflower${child.name}"] + 
                    (child.jsonlibs ? [downloadJson, extractNatives] : []) + 
                    (child.assets ? [downloadAssets] : []) + 
                    (PATH_INJECT != null ? ["fernflower${child.name}Inject"] : [])
                ) {
                    inputs.file PROJECT_TEMPLATE
                    if (child.jsonlibs)
                        inputs.file downloadJson.dest
                    if (PATH_INJECT != null)
                        inputs.file PATH_INJECT
                    outputs.file dir
                    doLast {
                        def name = child.name.toLowerCase()
                        def root = outputs.files.singleFile.absolutePath
                        if (!file(root).exists())
                            file(root).mkdirs()
                            
                        file(root + '/settings.gradle').withWriter('UTF-8'){ it.write("rootProject.name = '${project.name}-${name}'") }
                        
                        def template = PROJECT_TEMPLATE.text
                        def libraries = []
                        
                        if (child.jsonlibs) {
                            def json = new JsonSlurper().parse(downloadJson.dest)
                            libraries += json.libraries.findAll{ testJsonRules(it.rules) }.collect{lib -> "'${lib.name}'"}.unique{a,b -> a <=> b}
                        }
                        if (CONFIG?.libraries?.get(name) != null)
                            libraries += CONFIG.libraries.get(name).collect{"'${it}'"}
                        def filter = tasks.getByName("filter${child.extra}Extra").archivePath.absolutePath.replace('\\', '/')
                        libraries += ["files('${filter}')"]
                        
                        template = template.replace('{libraries}', 'compile ' + libraries.join('\n    compile '))
                        template = template.replace('{distro}', name)
                        template = template.replace('{inject}', PATH_INJECT == null ? 'null' : "'${PATH_INJECT.absolutePath.replace('\\', '/')}'")
                        template = template.replace('{assets}', "'${file(PATH_ASSETS).absolutePath.replace('\\', '/')}'")
                        template = template.replace('{natives}', "'${file(PATH_NATIVES).absolutePath.replace('\\', '/')}'")
                        
                        
                        file(root + '/build.gradle').withWriter('UTF-8'){ it.write(template) }
                    }
                }
                tasks.getByName("project${child.name}").mustRunAfter "project${child.name}Delete"
                projectAll.dependsOn "project${child.name}"

                task "project${child.name}Delete"(type: Delete) {
                    delete dir
                }
                projectDelete.dependsOn "project${child.name}Delete"

                task "project${child.name}Reset"(type: ResetSourcesTask, dependsOn: ["project${child.name}", "fernflower${child.name}"] + (MCPNAMES == null ? [] : ["mcpmap${child.name}"])) {
                    if (MCPNAMES == null)
                        root tasks.getByName("fernflower${child.name}").dest
                    else
                        root tasks.getByName("mcpmap${child.name}").outputs.files.singleFile
                    target new File(dir, 'src/main/java')
                }
                tasks.getByName("project${child.name}Reset").mustRunAfter "project${child.name}"
                projectReset.dependsOn "project${child.name}Reset"
                
                if (MCPNAMES == null ) {
                    task "project${child.name}ApplyPatches"(type: ApplyPatchesTask, dependsOn: ["project${child.name}Reset"]) {
                        target new File(dir, 'src/main/java')
                        patches dir_patches
                    }
                    projectApplyPatches.dependsOn "project${child.name}ApplyPatches"

                    task "project${child.name}MakePatches"(type: MakePatchesTask, dependsOn: ["fernflower${child.name}"]) {
                        root tasks.getByName("fernflower${child.name}").dest
                        target new File(dir, 'src/main/java')
                        patches dir_patches
                        doLast { //TODO: Update ProPatcher to normalize line endings
                            dir_patches.eachFileRecurse(FileType.FILES){ if (it.name.endsWith('.patch')) it.text = it.text.replaceAll('\r?\n', '\n') }
                        }
                    }
                    projectMakePatches.dependsOn "project${child.name}MakePatches"
                }
            }
        }
    }
   
    task generateConfiguration(type: SingleFileOutput) {
        inputs.property('config', CONFIG)
        dest file(PATH_CACHED_VERSION_DATA + 'config.json')

        doLast {
            def json = new JsonBuilder()
            def steps_def = [
                joined: [
                    [type: 'downloadManifest'],
                    [type: 'downloadJson'],
                    [type: 'downloadClient'],
                    [type: 'downloadServer'],
                    [type: 'strip', name: 'stripClient', input: '{downloadClientOutput}'],
                    [type: 'strip', name: 'stripServer', input: '{downloadServerOutput}'],
                    [type: 'merge', client: '{stripClientOutput}', server: '{stripServerOutput}', version: project.version],
                    [type: 'rename', input: '{mergeOutput}'],
                    [type: 'mcinject', input: '{renameOutput}'],
                    [type: 'listLibraries'],
                    [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{mcinjectOutput}'],
                    [type: 'inject', input: '{decompileOutput}'],
                    [type: 'patch', input: '{injectOutput}']
                ],
                client: [
                    [type: 'downloadManifest'],
                    [type: 'downloadJson'],
                    [type: 'downloadClient'],
                    [type: 'strip', input: '{downloadClientOutput}'],
                    [type: 'rename', input: '{stripOutput}'],
                    [type: 'mcinject', input: '{renameOutput}'],
                    [type: 'listLibraries'],
                    [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{mcinjectOutput}'],
                    [type: 'inject', input: '{decompileOutput}'],
                    [type: 'patch', input: '{injectOutput}']
                ],
                server: [
                    [type: 'downloadManifest'],
                    [type: 'downloadJson'],
                    [type: 'downloadServer'],
                    [type: 'strip', input: '{downloadServerOutput}'],
                    [type: 'rename', input: '{stripOutput}'],
                    [type: 'mcinject', input: '{renameOutput}'],
                    [type: 'listLibraries'],
                    [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{mcinjectOutput}'],
                    [type: 'inject', input: '{decompileOutput}'],
                    [type: 'patch', input: '{injectOutput}']
                ]
            ]
            json {
                spec 1
                version project.version
                data {
                    access 'config/access.txt'
                    constructors 'config/constructors.txt'
                    exceptions 'config/exceptions.txt'
                    mappings 'config/joined.tsrg'
                    inject 'config/inject/'
                    statics 'config/static_methods.txt'
                    patches {
                        client 'patches/client/'
                        joined 'patches/joined/'
                        server 'patches/server/'
                    }
                }
                steps steps_def
                functions {
                    decompile CONFIG.fernflower
                    mcinject CONFIG.mcinjector
                    merge CONFIG.merge
                    rename CONFIG.rename
                }
                libraries CONFIG.libraries
            }
            dest.write(json.toPrettyString())
        }
    }

    task makeZip(type: Zip, dependsOn: [makeSRG, dumpOverrides, dumpStatic, fixAccessLevels, makeExceptions]) {
        baseName = project.archivesBaseName
        version = project.version
        destinationDir = file(PATH_DISTRO)

        from generateConfiguration
        from(fixAccessLevels)                         { into 'config/' }
        from(file(PATH_VERSION + 'constructors.txt')) { into 'config/' }
        from(makeExceptions)                          { into 'config/' }
        from(file(PATH_VERSION + 'joined.tsrg'))      { into 'config/' }
        from(dumpStatic)                              { into 'config/' }

        def patches = file(PATH_VERSION + 'patches')
        if (patches.exists()) {
            from(patches) {
                into 'patches/'
            }
        }
        
        if (PATH_INJECT != null && PATH_INJECT.exists()) {
            from(PATH_INJECT) {
                into 'config/inject/'
            }
        }
    }
    
    task makeZipTimed(type: Zip, dependsOn: [makeZip, extractInheritance]) {
        baseName = project.archivesBaseName
        version = project.version + '-' + rootProject.TIMESTAMP
        destinationDir = file(PATH_DISTRO)
        from zipTree(makeZip.archivePath)
    }

    task verify(dependsOn: [mergeJars, extractInheritanceNamed]) {
        inputs.file mergeJars.dest
        inputs.file('joined.tsrg')
        doLast {
            def die = false
            
            // New Class naming standard adopted in 1.14
            // Interfaces prefixed with I
            // Enums NOT prefixed with Enum
            // Smurph Names moved to Suffix
            logger.lifecycle('ClassName:')
            def o2m = file('joined.tsrg').readLines().stream().map{ splitComment(it)[0].split(' ') }.filter{it.length == 2 && it[0].charAt(0) != '\t'}.collect(Collectors.toMap({l -> l[0]}, {l -> l[1]}))
            if (compareVersion('1.14', project.name) <= 0) {
                //TODO: Move this to MappingVerifier
                def m2o = o2m.collectEntries { e -> [(e.value): e.key] }
                
                def inh = new JsonSlurper().parseText(file(extractInheritanceNamed.dest).text)
                for (def key : inh.keySet().toSorted()) {
                    def entry = inh.get(key)
                    def errors = []
                    Set visited = ['java/lang/Object']
                    Set parents = [entry.name]
                    def q = [entry.name] as Queue
                    while (q.peek() != null) {
                        def parent = inh.get(q.poll())
                        if (parent != null) {
                            if (parent.superName != null && visited.add(parent.superName)) {
                                parents.add(parent.superName)
                                q.offer(parent.superName)
                            }
                            if (parent.interfaces != null) {
                                parent.interfaces.each { inf -> 
                                    if (inf != null && visited.add(inf)) {
                                        parents.add(inf)
                                        q.offer(inf)
                                    }
                                }
                            }
                        }
                    }
                    
                    def obf = m2o.get(entry.name)
                    def obfDepth = obf.split('\\$').length
                    def depth = entry.name.split('\\$').length
                    if (obfDepth != depth)
                        errors.add('Inner')
                    else {
                        if (obfDepth > 1) {
                            def obfParent = obf.substring(0, obf.lastIndexOf('$'))
                            def mapParent = o2m.get(obfParent)
                            def parent = entry.name.substring(0, entry.name.lastIndexOf('$'))
                            if (!parent.equals(mapParent))
                                errors.add('Parent: ' + mapParent)
                        }
                    }
                    
                    def idx = entry.name.lastIndexOf('/')
                    def name = entry.name.substring(idx+1)
                    idx = name.lastIndexOf('$')
                    if (idx != -1) 
                        name = name.substring(idx+1)
                    
                    if (!name.isNumber() && !obf.equals(entry.name)) { //Skip anon classes
                        
                        def isInterface  = (entry.access & 0x0200) != 0
                        def isAbstract   = (entry.access & 0x0400) != 0
                        def isAnnotation = (entry.access & 0x2000) != 0
                        def isEnum       = (entry.access & 0x4000) != 0
                        
                        if (isInterface && !isAnnotation && !name.startsWith('I'))
                            errors.add('Interface')
                        if (!isInterface && name.startsWith('I') && name.charAt(1).isUpperCase()){
                            if (!['IPBanList', 'IPBanEntry'].contains(name)) //Hardcode is bad
                                errors.add('Fake Interface')
                        }
                        if (isEnum && name.startsWith('Enum'))
                            errors.add('Enum')
                        /* This is a SHOULD not a MUST, so I have this disabled.
                        if (isAbstract && !isInterface && !isEnum && !name.startsWith('Abstract'))
                           errors.add('Abstract')
                        */
                        if ((name.contains('_') && !entry.name.startsWith('net/minecraft/util/datafix/versions/')) || name.contains('C_'))
                            errors.add('Underscore')
                        
                        if (file('suffixes.txt').exists()) {
                            def suffixes = [] as LinkedHashMap
                            file('suffixes.txt').readLines().stream().map{ splitComment(it)[0].split(' ') }.each { suffixes[it[0]] = it[1] }
                        
                            for (type in suffixes.keySet()) {
                                def suffix = suffixes.get(type)
                                if (parents.contains(type)) {
                                    if (!name.endsWith(suffix)) 
                                        errors.add('Suffix: ' + suffix)
                                    break //Only the first applicable one so we dont get multiple suffixes for a deep child
                                }
                            }
                        }
                    }
                    
                    if (!errors.isEmpty()) {
                        logger.lifecycle('  ' + entry.name + ' ' + errors)
                        die = true
                    }
                }
            } else {
                o2m.values().stream().filter{ it.contains('C_') }.each { logger.lifecycle('Unnamed: ' + it) }
                die |= o2m.values().stream().anyMatch { it.contains('C_') }
            }
            
            MappingVerifier mv = new MappingVerifier()
            mv.loadMap(file('joined.tsrg'))
            mv.loadJar(mergeJars.dest)
            mv.addDefaultTasks()
            if (!mv.verify()) {
                for (def t : mv.tasks) {
                    if (!t.errors.isEmpty()) {
                        if (t.name == 'OverrideNames') {
                            logger.lifecycle('Task: ' + t.name)
                            t.errors.each{ logger.lifecycle('  ' + it.stripIndent()) }
                            fixOverrides(t.errors, PATH_TSRG)
                        } else if (t.name == 'UniqueIDs') {
                            die |= fixUniqueIDs(t.errors, PATH_TSRG)
                        } else {
                            logger.lifecycle('Task: ' + t.name)
                            t.errors.each{ logger.lifecycle('  ' + it.stripIndent()) }
                            die = true
                        }
                    }
                }
            }
            if (die)
                throw new RuntimeException('Verification failed')
        }
    }
    //test.dependsOn(verify) ?

    task renameClasses() {
        doLast {
            def renames = [:]
            def rrenames = [:]
            def errors = []
            file('renames.txt').eachLine{ line ->
                def (entry, comment) = splitComment(line)
                if (entry == null)
                    return
                def (o, n) = entry.split(' ')
                if (renames.containsKey(o))
                    errors.add('Duplicate: ' + line + ' Old: ' + o + ' ' + renames[o]);
                if (rrenames.containsKey(n.toLowerCase()))
                    errors.add('Already Claimed: ' + line + ' Old: ' + rrenames[n.toLowerCase()] + ' ' + n);
                renames[o] = n
                rrenames[n.toLowerCase()] = o
                logger.lifecycle('Rename: ' + o + ' -> ' + n)
            }
            
            def lines = file(PATH_VERSION + 'joined.tsrg').readLines()
            
            def existing = lines.stream().map{ l -> splitComment(l)[0].split(' ') }.filter { l -> l.length == 2 }.map{ l -> l[1] }.collect(Collectors.toList())
            
            renames.each {o, n -> 
                if(existing.contains(n) && !renames.containsKey(n))
                    errors.add('Name Claimed with no rename: ' + o + ' -> ' + n)
            }
            
            if (!errors.isEmpty())
                throw new RuntimeException(errors.join('\n'))
            
            file(PATH_VERSION + 'joined.tsrg').withWriter('UTF-8') { writer ->
                lines.each { def line -> 
                    def (entry, comment) = splitComment(line)
                    if (line.startsWith('\t') || entry == null)
                        writer.write(line +'\n')
                    else {
                        def (obf, named) = entry.split(' ')
                        writer.write(obf + ' ' + rename(renames, named))
                        if (comment != null)
                            writer.write(' ' + comment)
                        writer.write('\n')
                    }
                }
            }
            
            lines = file(PATH_VERSION + 'constructors.txt').readLines()
            file(PATH_VERSION + 'constructors.txt').withWriter('UTF-8') { writer ->
                lines.each { def line -> 
                    def (entry, comment) = splitComment(line)
                    if (entry == null)
                        writer.write(line +'\n')
                    else {
                        def (id, cls, sig) = entry.split(' ')
                        writer.write(id + ' ' + rename(renames, cls) + ' ' + sig.replaceAll(/L([^;]+);/){m -> 'L' + rename(renames, m[1]) + ';'})
                        if (comment != null)
                            writer.write(' ' + comment)
                        writer.write('\n')
                    }
                }
            }
        }
    }

    artifacts {
        archives makeZip
        archives makeZipTimed
    }
        
    publishing {
        publications { 
            normal(MavenPublication) {
                artifactId project.archivesBaseName
                artifact makeZip
                pom {
                    name = 'MCPConfig'
                    description = 'Configuration files used for deobfuscating and modding Minecraft.'
                    url = 'https://github.com/MinecraftForge/MCPConfig'
                    scm {
                        url = 'https://github.com/MinecraftForge/MCPConfig'
                        connection = 'scm:git:git://github.com/MinecraftForge/MCPConfig.git'
                        developerConnection = 'scm:git:git@github.com:MinecraftForge/MCPConfig.git'
                    }
                    issueManagement {
                        system = 'github'
                        url = 'https://github.com/MinecraftForge/MCPConfig/issues'
                    }

                    licenses {
                        license {
                            name = 'All Rights Reserved, No redistribution.'
                            url = ''
                        }
                    }
                }
            } 
            timed(MavenPublication) {
                artifactId project.archivesBaseName
                version project.version + '-' + rootProject.TIMESTAMP
                artifact makeZip
                pom {
                    name = 'MCPConfig'
                    description = 'Configuration files used for deobfuscating and modding Minecraft.'
                    url = 'https://github.com/MinecraftForge/MCPConfig'
                    scm {
                        url = 'https://github.com/MinecraftForge/MCPConfig'
                        connection = 'scm:git:git://github.com/MinecraftForge/MCPConfig.git'
                        developerConnection = 'scm:git:git@github.com:MinecraftForge/MCPConfig.git'
                    }
                    issueManagement {
                        system = 'github'
                        url = 'https://github.com/MinecraftForge/MCPConfig/issues'
                    }

                    licenses {
                        license {
                            name = 'All Rights Reserved, No redistribution.'
                            url = ''
                        }
                    }
                }
            }
        }
        repositories {
            maven {
                if (project.hasProperty('mavenPassword')) {
                    credentials {
                        username = project.properties.mavenUser
                        password = project.properties.mavenPassword 
                    }
                    url 'http://files.minecraftforge.net/maven/manage/upload'
                } else {
                    url 'file://' + rootProject.file('repo').getAbsolutePath()
                }
            }
        }
    }
}

def fixOverrides(fixes, target) {
    def oldnames = [:]
    def newnames = [:]
    fixes.each{ line ->
        def (entry, comment) = splitComment(line.stripIndent())
        if (entry == null)
            return
        def pts = entry.split(' ')
        if (pts[0] == 'Override:') {
            if (pts.length != 7)
                throw new RuntimeException('Invalid override line: ' + line)
            def (cls, obf) = pts[1].split('/')
            oldnames.get(cls, [:])[obf + pts[2]] = pts[4]
            newnames.get(cls, [:])[obf + pts[2]] = pts[6]
        }
    }
    
    def lines = file(target).readLines()
    file(target).withWriter('UTF-8') { writer ->
        def currentCls = null
        for (def line : lines) {
            def (entry, comment) = splitComment(line)
            if (entry == null)
                writer.write(line +'\n')
            else if (!line.startsWith('\t')) {
                writer.write(line +'\n')
                currentCls = entry.split(' ')[0]
            } else {
                def pts = entry.substring(1).split(' ')
                if (pts.length != 3)
                    writer.write(line +'\n')
                else {
                    def key = pts[0] + pts[1]
                    if (oldnames.get(currentCls, [:]).containsKey(key)) {
                        writer.write('\t' + pts[0] + ' ' + pts[1] + ' ')
                        if (oldnames[currentCls][key] != pts[2]){
                            logger.lifecycle(String.format('  Skipped Rename: %s/%s %s Expected: %s Got: %s', currentCls, pts[0], pts[1], oldnames[currentCls][key], pts[2]))
                            writer.write(pts[2])
                        } else {
                            logger.lifecycle(String.format('  Rename: %s/%s %s %s -> %s', currentCls, pts[0], pts[1], pts[2], newnames[currentCls][key]))
                            writer.write(newnames[currentCls][key])
                        }
                        
                        if (comment != null)
                            writer.write(' ' + comment)
                        writer.write('\n')
                    } else {
                        writer.write(line +'\n')
                    }
                }
            }
        }
    }
}

def fixUniqueIDs(fixes, target) {
    def srg = loadSRG(file(target))
    def max = [srg['FD:'].collect{it.value.rsplit('/')[1]}.findAll{it.startsWith('field_')}.collect{it.split('_')[1].toInteger()}.max(), 
               srg['MD:'].collect{it.value.split(' ')[0].rsplit('/')[1]}.findAll{it.startsWith('func_')}.collect{it.split('_')[1].toInteger()}.max()].max() + 1
    
    logger.lifecycle('Task: UniqueIDs')
    //t.errors.each{ logger.lifecycle('  ' + it.stripIndent()) }
    def failed = false
    def renames = [:]
    fixes.each{ line ->
        def (entry, comment) = splitComment(line.stripIndent())
        if (entry == null)
            return
        def pts = entry.split(' ', 4)
        if (entry.startsWith('Duplicate ID:')) {
            if (pts.length != 4 || !pts[3].startsWith('(') || !pts[3].endsWith(')'))
                throw new RuntimeException('Invalid Duplicate line: ' + line)
            def ents = pts[3].substring(1, pts[3].length()-1).split(', ')
            
            if (pts[2] == '212853' || pts[2] == '212854') {
                println('  Detected known false positive (Generics issue): ' + line)
            } else if (ents.length == 1) {
                logger.lifecycle('  ' + line.stripIndent())
                println('Failed: Must process manually: ' + line)
                failed = true
            } else {
                logger.lifecycle('  ' + line.stripIndent())
                for(def x = 1; x < ents.length; x++) {
                    def p = ents[x].split('_')
                    p[1] = max++
                    renames[ents[x]] = p.join('_')
                    println(ents[x] + ' -> ' + renames[ents[x]])
                }   
            }
        }
    }
    
    def lines = file(target).readLines()
    file(target).withWriter('UTF-8') { writer ->
        def currentCls = null
        for (def line : lines) {
            def (entry, comment) = splitComment(line)
            if (entry == null)
                writer.write(line +'\n')
            else if (!line.startsWith('\t')) {
                writer.write(line +'\n')
                currentCls = entry.split(' ')[0]
            } else {
                def pts = entry.substring(1).split(' ')
                if (pts.length == 2) {   
                    def newName = renames.get(pts[1])
                    writer.write('\t' + pts[0] + ' ')
                    if (newName != null) {
                        logger.lifecycle(String.format('  Rename: %s/%s %s -> %s', currentCls, pts[0], pts[1], newName))
                        writer.write(newName)
                    } else {
                        writer.write(pts[1])
                    }
                    if (comment != null)
                        writer.write(' ' + comment)
                    writer.write('\n')
                } else if (pts.length == 3) {   
                    def newName = renames.get(pts[2])
                    writer.write('\t' + pts[0] + ' ' + pts[1] + ' ')
                    if (newName != null) {
                        logger.lifecycle(String.format('  Rename: %s/%s %s %s -> %s', currentCls, pts[0], pts[1], pts[2], newName))
                        writer.write(newName)
                    } else {
                        writer.write(pts[2])
                    }
                    if (comment != null)
                        writer.write(' ' + comment)
                    writer.write('\n')
                } else {
                    writer.write(line +'\n')
                }
            }
        }
    }
    return failed
}

def loadSRG(file) {
    def ret = ['PK:': [:], 'CL:': [:], 'FD:': [:], 'MD:': [:]]
    def lines = file.readLines().collect{ line -> splitComment(line)[0] }.findAll{line -> line != null && !line.trim().isEmpty() }
    if (ret.containsKey(lines[0].split(' ')[0])) {
        lines.each { line ->
            def pts = line.split(' ')
            if (pts[0] == 'PK:' || pts[0] == 'CL:' || pts[0] == 'FD:')
                ret[pts[0]][pts[1]] = pts[2]
            else if (pts[0] == 'MD:')
                ret[pts[0]][pts[1] + ' ' + pts[2]] = pts[3] + ' ' + pts[4]
        }
    } else {
        def currentCls = null
        def classes = [:]
        lines.findAll{line -> !line.startsWith('\t') && line.split(' ').length == 2}.each{l -> classes[l.split(' ')[0]] = l.split(' ')[1]}
        lines.each { line ->
            if (line.startsWith('\t')) {
                if (currentCls == null)
                    throw new IllegalStateException('Invalid TSRG Line, Missing currentCls: ' + file.absolutePath)
                line = currentCls + ' ' + line.substring(1)
            }
            def pts = line.trim().split(' ')
            if (pts.length == 2) {
                currentCls = pts[0]
                ret['CL:'][pts[0]] = pts[1]
            } else if (pts.length == 3)
                ret['FD:'][pts[0] + '/' + pts[1]] = rename(classes, pts[0]) + '/' + pts[2]
            else if (pts.length == 4)
                ret['MD:'][pts[0] + '/' + pts[1] + ' ' + pts[2]] = rename(classes, pts[0]) + '/' + pts[3] + ' ' + pts[2].replaceAll(/L([^;]+);/){m -> 'L' + rename(classes, m[1]) + ';'}
        }
    }
    
    return ret
}

def rename(map, entry) {
    def start = entry.lastIndexOf('$')
    return map.get(entry, (start == -1) ? entry : rename(map, entry.substring(0, start)) + entry.substring(start))
}

def splitComment(line) {
    def start = line.indexOf('#')
    if (start == -1)
        return [line, null]
    if (start == 0)
        return [null, line]
    return [line.substring(0, start - 1).replace('\\s+$', ''), line.substring(start)]
}

def getVersionIndex(prop, default_) {
    if (!project.hasProperty(prop))
        return default_
    if (!VERSIONS.contains(project.getProperty(prop))) 
        throw new IllegalArgumentException('Unknown version in ' + prop + ': ' + project.getProperty(prop) + ' Known: ' + VERSIONS.toString())
    return VERSIONS.indexOf(project.getProperty(prop))
}

def mavenPath(dep) {
    if (dep == null) return null
    def ext = 'jar'
    def idx = dep.indexOf('@')
    if (idx != -1) {
        ext = dep.substring(idx+1)
        dep = dep.substring(0,idx)
    }
    def pts = dep.split(':')
    return pts[0].replace('.', '/') + '/' + pts[1] + '/' + pts[2] + '/' + pts[1] + '-' + pts[2] + (pts.length > 3 ? '-' + pts[3] : '') + '.' + ext
}

def testJsonRules(rules) {
    if (rules == null) return true
    def allow = false
    for (def rule : rules) {
        def matched = true
        if (rule.os != null) {
            if (rule.os.name != null)
                matched &= getOsName().equals(rule.os.name)
            if (rule.os.version != null)
                matched &= Pattern.compile(rule.os.version).matcher(System.getProperty('os.version')).find()
            if (rule.os.arch != null)
                matched &= Pattern.compile(rule.os.arch).matcher(System.getProperty('os.arch')).find()
        }
        if (matched) allow = 'allow'.equals(rule.action)
    }
    return allow
}

def getOsName() {
    def name = System.getProperty('os.name').toLowerCase(java.util.Locale.ENGLISH)
    if (name.contains('windows') || name.contains('win')) return 'windows'
    if (name.contains('linux') || name.contains('unix')) return 'linux'
    if (name.contains('osx') || name.contains('mac')) return 'osx'
    return 'unknown'
}

def template = project(':' + VERSIONS[0])
def start = getVersionIndex('startVersion', 0)
def end = getVersionIndex('endVersion', VERSIONS.size - 1)

if (start > end)
    throw new IllegalArgumentException('Invalid start and end range: ' + VERSIONS[start] + ' > ' + VERSIONS[end])

template.tasks.each{t ->
    def myTask = project.tasks.findByName(t.name) ?: project.tasks.create(t.name)
    for (int x = start; x <= end; x++) {
        myTask.dependsOn project(VERSIONS[x]).tasks.findByName(t.name)
    }
}

